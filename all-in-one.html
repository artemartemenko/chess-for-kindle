<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Book of Games for Kindle</title><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><style>
:root {
    --color-bg-page: #f2ebe0;
    --color-bg-modal: #faf7f2;
    --color-text: #2c2c2c;
    --color-muted: #6b5b4f;
    --color-border: #c4b59a;
    --color-border-btn: #a08b6e;
    --color-disabled-bg: #e8e4dc;
    --color-disabled-text: #888;
    --piece-white-fill: #faf7f2;
    --piece-white-stroke: #2c2c2c;
    --piece-black-fill: #2c2c2c;
    --piece-black-stroke: #faf7f2;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    outline: none !important;
}

html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
    background-color: var(--color-bg-page);
}

body {
    font-family: "Bookerly", "Caecilia", Georgia, serif;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: default;
}

body.fullscreen-mode {
    padding: 0;
    margin: 0;
    background-color: #000;
}

body.fullscreen-mode .info,
body.fullscreen-mode .info-bottom {
    display: none;
}

body.fullscreen-mode .board-container {
    max-width: 100vh;
    max-height: 100vh;
    width: 100vw;
    height: 100vw;
    margin: 0;
}

body.fullscreen-mode .game-area,
body.fullscreen-mode .main-column {
    height: 100%;
    width: 100%;
}

.container {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

.game-area {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.main-column {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
}

.info, .info-bottom {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin: 5px 0;
    height: 44px;
    width: calc(100vw - 10px);
    max-width: calc(100vh - 115px);
}

.info { transform: rotate(180deg); }

.info-center {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    flex: 1;
    min-width: 0;
    height: 44px;
    padding: 0 0 2px 0;
    text-align: center;
}

.btn {
    height: 44px;
    padding: 0;
    font-family: "Bookerly", "Caecilia", Georgia, serif;
    font-size: 24px;
    font-weight: bold;
    background: #2c2c2c;
    color: #fff;
    border: 1px solid #1a1a1a;
    border-radius: 0;
    width: calc(12.5% + 2px);
    flex: 0 0 calc(12.5% + 2px);
    line-height: 40px;
    cursor: pointer;
    touch-action: manipulation;
}

.btn:disabled { background: var(--color-disabled-bg); border-color: var(--color-border); color: var(--color-disabled-text); }
.btn.btn-new,
.btn-roll { font-size: 16px; width: auto; padding: 0 12px; flex: 0 0 auto; }

.btn-nav {
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-appearance: none;
    appearance: none;
    padding: 0;
}

.btn-nav svg {
    width: 26px;
    height: 22px;
    display: block;
    flex-shrink: 0;
    margin: 0 auto;
}

.btn-nav svg path { fill: #fff !important; }

.promotion-content .btn {
    width: 100%;
    flex: none;
    display: block;
    padding: 0 20px;
}

.status, .status-bottom {
    font-size: 14px;
    font-weight: bold;
    color: #2c2c2c;
    line-height: 1.2;
    margin-top: 2px;
    white-space: nowrap;
}

.score {
    font-size: 13px;
    font-weight: bold;
    line-height: 13px;
    height: 13px;
    margin: 0;
    display: block;
    color: #005500;
    transform: translateY(1px);
}

.captured-inline {
    display: flex;
    align-items: flex-end;
    padding: 0 0 2px 0;
    width: 70px;
    flex: 0 0 70px;
    height: 44px;
}
.captured-row {
    display: flex;
    align-items: flex-end;
    margin-right: 3px;
    height: 16px;
}
#capturedTopB, #capturedBottomW { justify-content: flex-start; margin-left: 8px; }
#capturedTopW, #capturedBottomB { justify-content: flex-end; margin-right: 8px; }
.captured-count {
    font-size: 13px;
    font-weight: bold;
    line-height: 13px;
    height: 13px;
    margin: 0;
    display: block;
    color: #6b5b4f;
}
.captured-symbol {
    width: 16px;
    height: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.captured-symbol svg { width: 100%; height: 100%; }

.board {
    position: relative;
    width: 100%;
    height: 100%;
    border: 2px solid #c4b59a;
    background: #b58863;
}
.square {
    position: absolute;
    width: 12.5%;
    height: 12.5%;
    display: flex;
    justify-content: center;
    align-items: center;
    touch-action: manipulation;
}
.square.light { background-color: #F0E0C7; }
.square.dark { background-color: #b58863; }
.square.selected { background-color: #90a050 !important; border: 3px solid #2c2c2c !important; }
.square.last-move { background-color: #bac84a !important; border: 2px solid #2c2c2c !important; }
.square.possible-move::after {
    content: '';
    position: absolute;
    width: 30%;
    height: 30%;
    top: 35%;
    left: 35%;
    background-color: #5a5a5a;
    border-radius: 50%;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}
.square.possible-capture::after {
    content: '';
    position: absolute;
    width: 90%;
    height: 90%;
    top: 5%;
    left: 5%;
    border: 3px solid #5a5a5a;
    border-radius: 50%;
    box-sizing: border-box;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}
.piece {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
}
.rank1 { top: 87.5%; } .rank2 { top: 75%; } .rank3 { top: 62.5%; } .rank4 { top: 50%; }
.rank5 { top: 37.5%; } .rank6 { top: 25%; } .rank7 { top: 12.5%; } .rank8 { top: 0%; }
.file1 { left: 0%; } .file2 { left: 12.5%; } .file3 { left: 25%; } .file4 { left: 37.5%; }
.file5 { left: 50%; } .file6 { left: 62.5%; } .file7 { left: 75%; } .file8 { left: 87.5%; }

.board-container {
    width: calc(100vw - 10px);
    height: calc(100vw - 10px);
    max-width: calc(100vh - 115px);
    max-height: calc(100vh - 115px);
    margin: 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
}

.promotion-modal {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

[id$="welcomeModal"] {
    background: var(--color-bg-page);
}

[id$="welcomeModal"] .promotion-content {
    position: relative;
    background: var(--color-bg-modal);
    padding: 0;
    border: 1px solid var(--color-border);
    border-radius: 0;
    max-width: 400px;
    width: 90%;
    min-width: 340px;
    height: 580px;
    box-sizing: border-box;
    overflow: visible;
}

[id$="welcomeModal"] .promotion-content-inner {
    overflow-y: auto;
    height: 100%;
    padding: 2.5em 2em 1em 2em;
    box-sizing: border-box;
    text-align: center;
}

.welcome-back-wrap {
    position: absolute;
    top: -0.47em;
    left: 0.5em;
}

[id$="welcomeModal"] .welcome-back-link {
    display: block;
    width: 28px;
    height: 40px;
    text-decoration: none;
}

[id$="welcomeModal"] .welcome-back-link svg {
    width: 100%;
    height: 100%;
    display: block;
}

[id$="welcomeModal"] .welcome-back-link:hover svg path { fill: var(--color-text); }

[id$="welcomeModal"] .promotion-title {
    font-size: 1.5em;
    font-weight: 600;
    letter-spacing: 0.02em;
    margin: 0.4em 0 1em;
    padding-bottom: 0.6em;
    border-bottom: 1px solid var(--color-border);
    color: var(--color-text);
}

[id$="welcomeModal"] .btn {
    background: var(--color-bg-modal);
    border: 1px solid var(--color-border-btn);
    color: var(--color-text);
    padding-left: 30px;
    padding-right: 30px;
    width: 340px;
    box-sizing: border-box;
    font-size: 18px;
    font-weight: bold;
}

[id$="welcomeModal"] .btn:disabled { background: var(--color-disabled-bg); border-color: var(--color-border); color: var(--color-disabled-text); }
[id$="welcomeModal"] .welcome-continue-wrap { margin-bottom: 0.25em; }
[id$="welcomeModal"] .welcome-buttons-wrap { display: flex; flex-direction: column; align-items: center; margin: 0 auto; }
[id$="welcomeModal"] .welcome-buttons-wrap .title-page-actions,
[id$="welcomeModal"] .welcome-buttons-wrap .welcome-continue-wrap { display: flex; flex-direction: column; align-items: stretch; }
[id$="welcomeModal"] .title-page-actions { margin-top: 1em; }
[id$="welcomeModal"] .chapter-label {
    font-size: 0.75em;
    letter-spacing: 0.15em;
    color: var(--color-muted);
    text-transform: uppercase;
    margin-bottom: 0.5em;
}

.welcome-variants-info-wrap {
    position: absolute;
    top: -0.47em;
    right: 0.5em;
}

.welcome-variants-info-btn {
    width: 28px;
    height: 40px;
    padding: 0;
    border: none;
    background: transparent;
    cursor: pointer;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    display: block;
}

.welcome-variants-info-btn svg {
    width: 100%;
    height: 100%;
    display: block;
}

[id$="gameInfoModal"],
[id$="variantsInfoModal"] {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: transparent;
    z-index: 1002;
    align-items: center;
    justify-content: center;
    padding: 1em;
}

[id$="gameInfoModal"].show,
[id$="variantsInfoModal"].show { display: flex; }

[id$="gameInfoModal"] .variants-info-content,
[id$="variantsInfoModal"] .variants-info-content {
    position: relative;
    background: var(--color-bg-page);
    border: 1px solid var(--color-border);
    max-width: 380px;
    width: calc(90vw - 20px);
    min-width: 320px;
    height: 560px;
    box-sizing: border-box;
    overflow-y: auto;
    padding: 1.25em 1.5em;
}

[id$="gameInfoModal"] .variants-info-title,
[id$="variantsInfoModal"] .variants-info-title {
    font-size: 1.5em;
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: 0.75em;
    padding-bottom: 0.5em;
    border-bottom: 1px solid var(--color-border);
}

[id$="gameInfoModal"] .variant-item,
[id$="variantsInfoModal"] .variant-item {
    margin-bottom: 0.85em;
    font-size: 0.9em;
    line-height: 1.35;
    color: var(--color-text);
}

[id$="gameInfoModal"] .variant-item strong,
[id$="variantsInfoModal"] .variant-item strong { color: var(--color-text); }

[id$="gameInfoModal"] .variant-item span,
[id$="variantsInfoModal"] .variant-item span { color: var(--color-muted); }

[id$="gameInfoModal"] .variants-info-close,
[id$="variantsInfoModal"] .variants-info-close {
    position: absolute;
    top: 0.5em;
    right: 0.5em;
    width: 32px;
    height: 32px;
    margin: 16px;
    padding: 0;
    font-size: 0;
    line-height: 1;
    border: none;
    background: transparent;
    color: var(--color-text);
    cursor: pointer;
    touch-action: manipulation;
    display: flex;
    align-items: center;
    justify-content: center;
}
[id$="gameInfoModal"] .variants-info-close::before,
[id$="variantsInfoModal"] .variants-info-close::before {
    content: '×';
    font-size: 2.5rem;
}

[id$="eink-refresh-overlay"] {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: #000;
    display: none;
    z-index: 10001;
}

.main-footer,
[id$="welcomeFooter"] {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    text-align: center;
    padding: 10px;
    font-size: 12px;
    color: var(--color-muted);
}
[id$="welcomeFooter"] { display: none; z-index: 1001; }

.main-footer a,
[id$="welcomeFooter"] a {
    text-decoration: underline;
    color: var(--color-muted);
}
.main-footer a:hover,
[id$="welcomeFooter"] a:hover { color: var(--color-text); }

.welcome-continue-wrap {
    margin-top: 14px;
}

@media (max-width: 600px) {
    .btn { font-size: 18px; line-height: 44px; }
}

.container {
                width: 100%;
                max-width: 360px;
                padding: 20px;
                text-align: center;
                height: auto;
            }
            .cover-outer {
            border: 2px solid #a08b6e;
            padding: 0.75em;
            max-width: 380px;
            width: calc(100% - 2em);
            margin: 0 1em;
        }
        .cover-frame {
            border: 2px solid #c4b59a;
            padding: 2em;
            max-width: 100%;
        }
        .contents-label {
            font-size: 0.75em;
            letter-spacing: 0.15em;
            color: #6b5b4f;
            text-transform: uppercase;
            margin-bottom: 0.8em;
        }
        .contents-heading {
            font-size: 0.75em;
            letter-spacing: 0.15em;
            color: #6b5b4f;
            text-transform: uppercase;
            margin-bottom: 0.6em;
            margin-top: 0.4em;
        }
        h1 {
            font-size: 1.5em;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #2c2c2c;
            margin-bottom: 1em;
            padding-bottom: 0.6em;
            border-bottom: 1px solid #c4b59a;
            line-height: 1.3;
        }
        .book-byline {
            display: block;
            font-size: 0.75em;
            font-weight: normal;
            letter-spacing: 0.12em;
            color: #6b5b4f;
            margin-top: 0.35em;
        }
        .cover-icon {
            display: block;
            width: 64px;
            height: auto;
            margin: 0.6em auto 0.5em;
        }
        .cover-icon svg {
            width: 100%;
            height: auto;
            display: block;
        }
        .subtitle {
            font-size: 14px;
            color: #6b5b4f;
            margin-bottom: 30px;
            line-height: 1.3;
        }
        .btn-game {
            display: block;
            width: 100%;
            height: 56px;
            line-height: 54px;
            margin-bottom: 16px;
            font-family: "Bookerly", "Caecilia", Georgia, serif;
            font-size: 18px;
            font-weight: bold;
            color: #2c2c2c;
            background: #faf7f2;
            border: 1px solid #a08b6e;
            border-radius: 0;
            text-decoration: none;
            touch-action: manipulation;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-game:hover,
        .btn-game:active {
            background: #faf7f2;
            color: #2c2c2c;
        }
#screen-main, .game-screen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; overflow: auto; }
#screen-main { display: flex; width: 100%; height: 100%; z-index: 0; }
.game-screen { display: none; width: 100%; height: 100%; z-index: 1; }
 #screen-chess .square.check { background-color: #cc5555 !important; } #screen-chess .piece svg { width: 70%; height: 70%; } #screen-chess .board.black-turn .piece { transform: rotate(180deg); } #screen-chess .board.rotation-locked { transform: rotate(0deg) !important; } #screen-chess .board.rotation-locked .piece[data-piece^="b"] { transform: rotate(180deg) !important; } #screen-chess .board.rotation-locked .piece[data-piece^="w"] { transform: rotate(0deg) !important; } #screen-chess #chess-promotionModal .promotion-content {
                background: #faf7f2;
                padding: 1.25em 1.5em;
                border: 1px solid #c4b59a;
                border-radius: 0;
                text-align: center;
                max-width: 90%;
            } #screen-chess #chess-promotionModal .promotion-content .promotion-title {
                font-size: 1.5em;
                font-weight: 600;
                letter-spacing: 0.02em;
                margin: 0.4em 0 1em;
                padding-bottom: 0.6em;
                border-bottom: 1px solid #c4b59a;
                color: #2c2c2c;
            } #screen-chess .promotion-options { display: flex; justify-content: center; } #screen-chess .promo-option {
                cursor: pointer; width: 55px; height: 55px;
                border: 1px solid #ccc; display: flex;
                justify-content: center; align-items: center;
                margin: 0 8px;
                touch-action: manipulation;
            } #screen-chess .promo-option svg { width: 70%; height: 70%; }
 #screen-checkers .piece svg { width: 98%; height: 98%; } #screen-checkers .board.size-8 .square { width: 12.5%; height: 12.5%; } #screen-checkers .board.size-8 .square.rank1 { top: 87.5%; } #screen-checkers .board.size-8 .square.rank2 { top: 75%; } #screen-checkers .board.size-8 .square.rank3 { top: 62.5%; } #screen-checkers .board.size-8 .square.rank4 { top: 50%; } #screen-checkers .board.size-8 .square.rank5 { top: 37.5%; } #screen-checkers .board.size-8 .square.rank6 { top: 25%; } #screen-checkers .board.size-8 .square.rank7 { top: 12.5%; } #screen-checkers .board.size-8 .square.rank8 { top: 0%; } #screen-checkers .board.size-8 .square.file1 { left: 0%; } #screen-checkers .board.size-8 .square.file2 { left: 12.5%; } #screen-checkers .board.size-8 .square.file3 { left: 25%; } #screen-checkers .board.size-8 .square.file4 { left: 37.5%; } #screen-checkers .board.size-8 .square.file5 { left: 50%; } #screen-checkers .board.size-8 .square.file6 { left: 62.5%; } #screen-checkers .board.size-8 .square.file7 { left: 75%; } #screen-checkers .board.size-8 .square.file8 { left: 87.5%; } #screen-checkers .board.size-10 .square { width: 10%; height: 10%; } #screen-checkers .board.size-10 .square.rank1 { top: 90%; } #screen-checkers .board.size-10 .square.rank2 { top: 80%; } #screen-checkers .board.size-10 .square.rank3 { top: 70%; } #screen-checkers .board.size-10 .square.rank4 { top: 60%; } #screen-checkers .board.size-10 .square.rank5 { top: 50%; } #screen-checkers .board.size-10 .square.rank6 { top: 40%; } #screen-checkers .board.size-10 .square.rank7 { top: 30%; } #screen-checkers .board.size-10 .square.rank8 { top: 20%; } #screen-checkers .board.size-10 .square.rank9 { top: 10%; } #screen-checkers .board.size-10 .square.rank10 { top: 0%; } #screen-checkers .board.size-10 .square.file1 { left: 0%; } #screen-checkers .board.size-10 .square.file2 { left: 10%; } #screen-checkers .board.size-10 .square.file3 { left: 20%; } #screen-checkers .board.size-10 .square.file4 { left: 30%; } #screen-checkers .board.size-10 .square.file5 { left: 40%; } #screen-checkers .board.size-10 .square.file6 { left: 50%; } #screen-checkers .board.size-10 .square.file7 { left: 60%; } #screen-checkers .board.size-10 .square.file8 { left: 70%; } #screen-checkers .board.size-10 .square.file9 { left: 80%; } #screen-checkers .board.size-10 .square.file10 { left: 90%; }
 #screen-reversi .board { background: #5a7a5a; } #screen-reversi .square {
            background-color: #5a7a5a;
            box-sizing: border-box;
            border-right: 1px solid #4a6a4a;
            border-bottom: 1px solid #4a6a4a;
        } #screen-reversi .square.file1 { border-left: 1px solid #4a6a4a; } #screen-reversi .square.rank8 { border-top: 1px solid #4a6a4a; } #screen-reversi .square.last-move { background-color: #5a7a5a !important; border: 2px solid #2c2c2c !important; } #screen-reversi .board.black-turn .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            top: 37.5%;
            left: 37.5%;
            background-color: #2c2c2c;
            border: 1px solid #faf7f2;
            border-radius: 50%;
            box-sizing: border-box;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        } #screen-reversi .board.white-turn .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            top: 37.5%;
            left: 37.5%;
            background-color: #faf7f2;
            border: 1px solid #2c2c2c;
            border-radius: 50%;
            box-sizing: border-box;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        } #screen-reversi .piece svg { width: 90%; height: 90%; }
 #screen-peg .btn { width: 48px; flex: 0 0 48px; } #screen-peg .score-bottom { font-size: 13px; font-weight: bold; color: #6b5b4f; line-height: 1.2; margin-top: 2px; } #screen-peg .board {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            background: transparent;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(7, 1fr);
        } #screen-peg .hole {
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            position: relative;
            background: #b58863;
            border: 1px solid #a07850;
        } #screen-peg .hole::before { display: none; } #screen-peg .hole.invalid { background: transparent; border-color: transparent; pointer-events: none; } #screen-peg .hole.selected .peg-dot { box-shadow: 0 0 0 5px var(--color-bg-modal); } #screen-peg .hole.possible::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            top: 35%;
            left: 35%;
            background-color: #5a5a5a;
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
        } #screen-peg .hole .peg-dot {
            width: 60%;
            height: 60%;
            border-radius: 50%;
            background: var(--piece-black-fill);
            border: 1px solid #1a1a1a;
            position: relative;
            z-index: 1;
        } #screen-peg .hole .peg-dot.hidden { display: none; }
 #screen-backgammon .btn { width: 48px; flex: 0 0 48px; } #screen-backgammon .board-wrap {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border: 2px solid #c4b59a;
            background: #b58863;
        } #screen-backgammon .board-half { display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0; } #screen-backgammon .board-row { display: flex; width: 100%; flex: 1; min-height: 0; } #screen-backgammon .board-row .point:nth-child(odd) { background: #b58863; } #screen-backgammon .board-row .point:nth-child(even) { background: #F0E0C7; } #screen-backgammon .point {
            flex: 1; min-width: 0; display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            border-right: 1px solid #a07850; padding: 2px; touch-action: manipulation; position: relative;
        } #screen-backgammon .point:last-child { border-right: none; } #screen-backgammon .point.selected { background: #90a050 !important; border: 2px solid #2c2c2c !important; } #screen-backgammon .point.possible { background: #bac84a !important; border: 2px solid #2c2c2c !important; } #screen-backgammon .point-num { font-size: 10px; color: #6b5b4f; position: absolute; top: 1px; } #screen-backgammon .board-row .point:nth-child(odd) .point-num { color: #f2ebe0; } #screen-backgammon .checker-stack { display: flex; flex-direction: column-reverse; align-items: center; gap: 1px; } #screen-backgammon .checker {
            width: 14px; height: 14px; border-radius: 50%; border: 1px solid;
            -webkit-transform: translateZ(0); transform: translateZ(0);
        } #screen-backgammon .checker.white { background: var(--piece-white-fill); border-color: var(--piece-white-stroke); } #screen-backgammon .checker.black { background: var(--piece-black-fill); border-color: var(--piece-black-stroke); } #screen-backgammon .bar-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex: 0 0 20px;
            min-width: 20px;
            background: #a07850;
            border-left: 1px solid #8a6840;
            border-right: 1px solid #8a6840;
            cursor: pointer;
            touch-action: manipulation;
        } #screen-backgammon .bar-area.selected { background: #90a050; } #screen-backgammon .bar-label { font-size: 10px; color: #faf7f2; margin: 2px 0; white-space: nowrap; } #screen-backgammon .dice-area { display: flex; justify-content: center; align-items: center; gap: 12px; padding: 8px; background: #f2ebe0; } #screen-backgammon .die { width: 36px; height: 36px; border: 2px solid #2c2c2c; background: #faf7f2; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: #2c2c2c; }
</style></head><body><div id="screen-main" class="container"><div class="container">
        <div class="cover-outer">
            <div class="cover-frame">
                <p class="contents-label">For Kindle</p>
            <span class="cover-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 592.5 326.1"><path d="M130.7 12v60.5l140 86.5zM65 56v43.5l157 50zM214 0v73.5l72.4 74.7z" fill="#2c2c2c"/><path d="M296.3 191.9 0 100l88 188.5h416.5l88-188.5zM296 305H95.6l9.9 21.1H487l9.9-21.1H296.5z" fill="#2c2c2c"/><path d="M461.8 72.5V12l-140 147zm65.7 27V56l-157 93.5zM378.5 0l-72.4 148.2 72.4-74.7z" fill="#2c2c2c"/></svg></span>
            <h1>Book of Games</h1>
                <p class="contents-heading">Contents</p>
                <a href="#chess" class="btn-game">Chess</a>
                <a href="#checkers" class="btn-game">Checkers</a>
                <a href="#reversi" class="btn-game">Reversi</a>
                <a href="#peg" class="btn-game">Peg Solitaire</a>
                <!-- <a href="#backgammon" class="btn-game">Backgammon</a> -->
            </div>
        </div>
    </div>
    <div class="main-footer">
        <a href="https://github.com/artemartemenko/chess-for-kindle" target="_blank">GitHub</a>
        <span> · Book of Games for Kindle</span>
    </div></div><div id="screen-chess" class="game-screen" style="display:none;"><div id="chess-eink-refresh-overlay"></div><div class="container"><div class="container">
            <div id="chess-promotionModal" class="promotion-modal" style="display: none;">
                <div class="promotion-content">
                    <div class="promotion-title">Promote to:</div>
                    <div class="promotion-options">
                        <div class="promo-option" data-type="Q"></div>
                        <div class="promo-option" data-type="R"></div>
                        <div class="promo-option" data-type="B"></div>
                        <div class="promo-option" data-type="N"></div>
                    </div>
                </div>
            </div>

            <div id="chess-welcomeModal" class="promotion-modal">
                <div class="promotion-content title-page">
                    <div class="welcome-back-wrap">
                        <a href="#" onclick="location.hash='';return false;" class="welcome-back-link" title="Contents"></a>
                    </div>
                    <div class="welcome-variants-info-wrap">
                        <button type="button" id="chess-gameInfoBtn" class="welcome-variants-info-btn" title="About"></button>
                    </div>
                    <div class="promotion-content-inner">
                        <p class="chapter-label">Chapter 1</p>
                        <h1 class="promotion-title">Chess</h1>
                        <div class="welcome-buttons-wrap">
                            <div class="welcome-continue-wrap title-page-continue">
                                <button id="chess-continueGameBtn" class="btn">Continue</button>
                            </div>
                            <div class="title-page-actions">
                                <button id="chess-newGameBtn" class="btn">New game</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="chess-gameInfoModal" class="promotion-modal" aria-hidden="true">
                <div class="variants-info-content">
                    <div class="variants-info-title">Chess</div>
                    <div class="variant-item">Double-tap any empty square to <strong>lock piece rotation</strong>.</div>
                    <div class="variant-item">Double-tap outside the board to toggle <strong>fullscreen</strong>.</div>
                    <div class="variant-item">Offline mode implemented.</div>
                    <button type="button" id="chess-gameInfoClose" class="variants-info-close">Close</button>
                </div>
            </div>

            <div id="chess-welcomeFooter" style="display: block;">
                <span>Edition 1.3</span>
            </div>
    
            <div class="game-area">
                <div class="main-column">
                    <div class="info">
                        <button id="chess-backBtn" class="btn btn-nav btn-nav-back" type="button"></button>
                        <div class="captured-inline" id="chess-capturedTopB"></div>
                        <div class="info-center">
                            <div class="status" id="chess-status">White to move</div>
                            <div class="score" id="chess-scoreTop"></div>
                        </div>
                        <div class="captured-inline" id="chess-capturedTopW"></div>
                        <button id="chess-forwardBtn" class="btn btn-nav btn-nav-forward" type="button"></button>
                    </div>
                    <div class="board-container">
                        <div class="board" id="chess-board"></div>
                    </div>
                    <div class="info-bottom">
                        <button id="chess-backBtnBottom" class="btn btn-nav btn-nav-back" type="button"></button>
                        <div class="captured-inline" id="chess-capturedBottomW"></div>
                        <div class="info-center">
                            <div class="status-bottom" id="chess-statusBottom">White to move</div>
                            <div class="score" id="chess-scoreBottom"></div>
                        </div>
                        <div class="captured-inline" id="chess-capturedBottomB"></div>
                        <button id="chess-forwardBtnBottom" class="btn btn-nav btn-nav-forward" type="button"></button>
                    </div>
                </div>
            </div>
        </div></div></div>
<div id="screen-checkers" class="game-screen" style="display:none;"><div id="checkers-eink-refresh-overlay"></div><div class="container"><div class="container">
            <div id="checkers-welcomeModal" class="promotion-modal">
                <div class="promotion-content title-page">
                    <div class="welcome-back-wrap">
                        <a href="#" onclick="location.hash='';return false;" class="welcome-back-link" title="Contents"></a>
                    </div>
                    <div class="welcome-variants-info-wrap">
                        <button type="button" id="checkers-variantsInfoBtn" class="welcome-variants-info-btn" title="About variants"></button>
                    </div>
                    <div class="promotion-content-inner">
                        <p class="chapter-label">Chapter 2</p>
                        <h1 class="promotion-title">Checkers</h1>
                        <div class="welcome-buttons-wrap">
                            <div class="welcome-continue-wrap title-page-continue">
                                <button id="checkers-continueGameBtn" class="btn">Continue</button>
                            </div>
                            <div class="title-page-actions">
                                <button id="checkers-modeEnglishBtn" class="btn" style="margin-bottom: 10px;">English (8×8)</button>
                                <button id="checkers-modePoolBtn" class="btn" style="margin-bottom: 10px;">Pool (8×8)</button>
                                <button id="checkers-modeBrazilianBtn" class="btn" style="margin-bottom: 10px;">Brazilian (8×8)</button>
                                <button id="checkers-modeInternationalBtn" class="btn" style="margin-bottom: 10px;">International (10×10)</button>
                                <button id="checkers-modeCanadianBtn" class="btn">Canadian (12×12)</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="checkers-variantsInfoModal" class="promotion-modal" aria-hidden="true">
                <div class="variants-info-content">
                    <div class="variants-info-title">Checkers variants</div>
                    <div class="variant-item"><strong>English</strong> (8×8)<br><span>Black moves first. Kings move 1 square. Simple pieces jump forward only. Max capture not required.</span></div>
                    <div class="variant-item"><strong>Pool</strong> (8×8)<br><span>Black moves first. Flying kings. Simple pieces jump backward. Max capture required.</span></div>
                    <div class="variant-item"><strong>Brazilian</strong> (8×8)<br><span>White moves first. Flying kings. Simple pieces jump backward. Max capture required.</span></div>
                    <div class="variant-item"><strong>International</strong> (10×10)<br><span>White moves first. Flying kings. Simple pieces jump backward in series. Max capture required.</span></div>
                    <div class="variant-item"><strong>Canadian</strong> (12×12)<br><span>White moves first. Flying kings. Simple pieces jump backward in series. Max capture required.</span></div>
                    
                    <button type="button" id="checkers-variantsInfoClose" class="variants-info-close">Close</button>
                </div>
            </div>

            <div id="checkers-welcomeFooter" style="display: block;">
                <span>Edition 1.0</span>
            </div>
    
            <div class="game-area">
                <div class="main-column">
                    <div class="info">
                        <button id="checkers-backBtn" class="btn btn-nav btn-nav-back" type="button"></button>
                        <div class="captured-inline" id="checkers-capturedTopB"></div>
                        <div class="info-center">
                            <div class="status" id="checkers-status">White to move</div>
                            <div class="score" id="checkers-scoreTop"></div>
                        </div>
                        <div class="captured-inline" id="checkers-capturedTopW"></div>
                        <button id="checkers-forwardBtn" class="btn btn-nav btn-nav-forward" type="button"></button>
                    </div>
                    <div class="board-container">
                        <div class="board size-8" id="checkers-board"></div>
                    </div>
                    <div class="info-bottom">
                        <button id="checkers-backBtnBottom" class="btn btn-nav btn-nav-back" type="button"></button>
                        <div class="captured-inline" id="checkers-capturedBottomW"></div>
                        <div class="info-center">
                            <div class="status-bottom" id="checkers-statusBottom">White to move</div>
                            <div class="score" id="checkers-scoreBottom"></div>
                        </div>
                        <div class="captured-inline" id="checkers-capturedBottomB"></div>
                        <button id="checkers-forwardBtnBottom" class="btn btn-nav btn-nav-forward" type="button"></button>
                    </div>
                </div>
            </div>
        </div></div></div>
<div id="screen-reversi" class="game-screen" style="display:none;"><div id="reversi-eink-refresh-overlay"></div><div class="container"><div class="container">
        <div id="reversi-welcomeModal" class="promotion-modal">
            <div class="promotion-content title-page">
                <div class="welcome-back-wrap">
                    <a href="#" onclick="location.hash='';return false;" class="welcome-back-link" title="Contents"></a>
                </div>
                <div class="welcome-variants-info-wrap">
                    <button type="button" id="reversi-gameInfoBtn" class="welcome-variants-info-btn" title="Rules"></button>
                </div>
                <div class="promotion-content-inner">
                    <p class="chapter-label">Chapter 3</p>
                    <h1 class="promotion-title">Reversi</h1>
                    <div class="welcome-buttons-wrap">
                        <div class="welcome-continue-wrap">
                            <button id="reversi-continueGameBtn" class="btn">Continue</button>
                        </div>
                        <div class="title-page-actions">
                            <button id="reversi-newGameBtn" class="btn">New game</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="reversi-gameInfoModal" class="promotion-modal" aria-hidden="true">
            <div class="variants-info-content">
                <div class="variants-info-title">Reversi — rules</div>
                <div class="variant-item"><strong>Objective.</strong> <span>Finish with more discs of your color than your opponent.</span></div>
                <div class="variant-item"><strong>Move.</strong> <span>Place a disc on an empty square so that at least one straight line (horizontal, vertical, or diagonal) runs from your new disc through one or more opponent discs to another disc of your color. All opponent discs on that line are flipped to your color.</span></div>
                <div class="variant-item"><strong>Pass.</strong> <span>If you have no valid move, you must pass. When both players pass in a row, the game ends. The player with more discs wins; equal count is a draw.</span></div>
                <div class="variant-item"><strong>Start.</strong> <span>Black moves first. The initial four discs are placed in the center; valid first moves are only those that flip at least one white disc.</span></div>
                <button type="button" id="reversi-gameInfoClose" class="variants-info-close">Close</button>
            </div>
        </div>
        <div id="reversi-welcomeFooter" style="display: block;">
            <span>Edition 1.0</span>
        </div>
        <div class="game-area">
            <div class="main-column">
                <div class="info">
                    <button id="reversi-backBtn" class="btn btn-nav btn-nav-back" type="button"></button>
                    <div class="info-center">
                        <div class="status" id="reversi-status">Black to move</div>
                        <div class="score" id="reversi-scoreTop"></div>
                    </div>
                    <button id="reversi-forwardBtn" class="btn btn-nav btn-nav-forward" type="button"></button>
                </div>
                <div class="board-container">
                    <div class="board" id="reversi-board"></div>
                </div>
                <div class="info-bottom">
                    <button id="reversi-backBtnBottom" class="btn btn-nav btn-nav-back" type="button"></button>
                    <div class="info-center">
                        <div class="status-bottom" id="reversi-statusBottom">Black to move</div>
                        <div class="score" id="reversi-scoreBottom"></div>
                    </div>
                    <button id="reversi-forwardBtnBottom" class="btn btn-nav btn-nav-forward" type="button"></button>
                </div>
            </div>
        </div>
    </div></div></div>
<div id="screen-peg" class="game-screen" style="display:none;"><div id="peg-eink-refresh-overlay"></div><div class="container"><div class="container">
        <div id="peg-welcomeModal" class="promotion-modal">
            <div class="promotion-content title-page">
                <div class="welcome-back-wrap">
                    <a href="#" onclick="location.hash='';return false;" class="welcome-back-link" title="Contents"></a>
                </div>
                <div class="welcome-variants-info-wrap">
                    <button type="button" id="peg-gameInfoBtn" class="welcome-variants-info-btn" title="About the game"></button>
                </div>
                <div class="promotion-content-inner">
                    <p class="chapter-label">Chapter 4</p>
                    <h1 class="promotion-title">Peg Solitaire</h1>
                    <div class="welcome-buttons-wrap">
                        <div class="welcome-continue-wrap">
                            <button id="peg-continueGameBtn" class="btn">Continue</button>
                        </div>
                        <div class="title-page-actions">
                            <button id="peg-newGameEnglishBtn" class="btn" style="margin-bottom: 10px;">English (33)</button>
                            <button id="peg-newGameFrenchBtn" class="btn">French (37)</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="peg-gameInfoModal" class="promotion-modal" aria-hidden="true">
            <div class="variants-info-content">
                <div class="variants-info-title">Peg Solitaire</div>
                <div class="variant-item">Jump a peg over an adjacent peg into an empty cell; the jumped peg is removed. Only horizontal and vertical jumps. Goal: leave a single peg on the board (ideally in the center).</div>
                <div class="variant-item"><strong>English</strong> (33) and <strong>French</strong> (37) differ only in board shape.</div>
                <button type="button" id="peg-gameInfoClose" class="variants-info-close">Close</button>
            </div>
        </div>
        <div id="peg-welcomeFooter" style="display: block;"><span>Edition 1.0</span></div>
        <div class="game-area">
            <div class="main-column">
                <div class="board-container">
                    <div id="peg-board" class="board"></div>
                </div>
                <div class="info-bottom">
                    <button id="peg-backBtnBottom" class="btn btn-nav btn-nav-back" type="button"></button>
                    <div class="info-center">
                        <div class="status-bottom" id="peg-statusBottom"></div>
                        <div class="score-bottom" id="peg-scoreBottom">Pegs: 32</div>
                    </div>
                    <button id="peg-forwardBtnBottom" class="btn btn-nav btn-nav-forward" type="button"></button>
                </div>
            </div>
        </div>
    </div></div></div>
<div id="screen-backgammon" class="game-screen" style="display:none;"><div id="backgammon-eink-refresh-overlay"></div><div class="container"><div class="container">
        <div id="backgammon-welcomeModal" class="promotion-modal" style="display: none;">
            <div class="promotion-content title-page">
                <div class="welcome-back-wrap">
                    <a href="#" onclick="location.hash='';return false;" class="welcome-back-link" title="Contents"></a>
                </div>
                <div class="welcome-variants-info-wrap">
                    <button type="button" id="backgammon-gameInfoBtn" class="welcome-variants-info-btn" title="Rules"></button>
                </div>
                <div class="promotion-content-inner">
                    <p class="chapter-label">Chapter 5</p>
                    <h1 class="promotion-title">Backgammon</h1>
                    <div class="welcome-buttons-wrap">
                        <div class="welcome-continue-wrap title-page-continue">
                            <button id="backgammon-continueGameBtn" class="btn">Continue</button>
                        </div>
                        <div class="title-page-actions">
                            <button id="backgammon-newGameBtn" class="btn">New game</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="backgammon-gameInfoModal" class="promotion-modal" aria-hidden="true">
            <div class="variants-info-content">
                <div class="variants-info-title">Backgammon — rules</div>
                <div class="variant-item"><strong>Objective.</strong> <span>Bear off all 15 of your checkers before your opponent.</span></div>
                <div class="variant-item"><strong>Roll.</strong> <span>Roll the dice to get your move numbers. On a double you play the number four times.</span></div>
                <div class="variant-item"><strong>Move.</strong> <span>Move one checker forward by the number on a die. You may hit a blot (single opponent checker), which then goes to the bar and must re-enter. No move to a point with two or more opponent checkers.</span></div>
                <div class="variant-item"><strong>Bear off.</strong> <span>When all your checkers are in your home board, remove them by rolling the exact point number or higher.</span></div>
                <button type="button" id="backgammon-gameInfoClose" class="variants-info-close">Close</button>
            </div>
        </div>
        <div id="backgammon-welcomeFooter" style="display: block;"><span>Edition 1.0</span></div>
        <div class="game-area">
            <div class="main-column">
                <div class="info">
                    <button id="backgammon-backBtn" class="btn btn-nav btn-nav-back" type="button"></button>
                    <div class="info-center">
                        <div class="status" id="backgammon-status">White to roll</div>
                    </div>
                    <button id="backgammon-forwardBtn" class="btn btn-nav btn-nav-forward" type="button"></button>
                </div>
                <div class="board-container">
                    <div id="backgammon-boardWrap" class="board-wrap"></div>
                </div>
                <div class="dice-area">
                    <span id="backgammon-die1" class="die">–</span>
                    <span id="backgammon-die2" class="die">–</span>
                    <button id="backgammon-rollBtn" class="btn btn-roll" style="display:none;">Roll</button>
                </div>
                <div class="info-bottom">
                    <button id="backgammon-backBtnBottom" class="btn btn-nav btn-nav-back" type="button"></button>
                    <div class="info-center">
                        <div class="status-bottom" id="backgammon-statusBottom">White to roll</div>
                    </div>
                    <button id="backgammon-forwardBtnBottom" class="btn btn-nav" type="button"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="183.2" height="145" viewBox="0 0 183.2 145"><path d="m87.1 0-.2 47.6H0v49.8h86.9l.2 47.6 96.1-72.5z" style="fill:#2c2c2c"/></svg></button>
                </div>
            </div>
        </div>
    </div></div></div><script>
if (!Element.prototype.closest) {
    Element.prototype.closest = function(s) {
        var el = this;
        do {
            if (el.nodeType === 1 && (el.matches || el.webkitMatchesSelector || el.msMatchesSelector).call(el, s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el && el !== document.body);
        return null;
    };
}

function loadJSON(key) {
    try {
        var raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : null;
    } catch (e) { return null; }
}
function saveJSON(key, data) {
    localStorage.setItem(key, JSON.stringify(data));
}
function clearSaved(key) {
    localStorage.removeItem(key);
}

var PIECE_WHITE_FILL, PIECE_WHITE_STROKE, PIECE_BLACK_FILL, PIECE_BLACK_STROKE;
(function() {
    var cs = document.documentElement && getComputedStyle(document.documentElement);
    if (cs) {
        PIECE_WHITE_FILL = (cs.getPropertyValue('--piece-white-fill') || '#faf7f2').trim();
        PIECE_WHITE_STROKE = (cs.getPropertyValue('--piece-white-stroke') || '#2c2c2c').trim();
        PIECE_BLACK_FILL = (cs.getPropertyValue('--piece-black-fill') || '#2c2c2c').trim();
        PIECE_BLACK_STROKE = (cs.getPropertyValue('--piece-black-stroke') || '#faf7f2').trim();
    } else {
        PIECE_WHITE_FILL = '#faf7f2';
        PIECE_WHITE_STROKE = '#2c2c2c';
        PIECE_BLACK_FILL = '#2c2c2c';
        PIECE_BLACK_STROKE = '#faf7f2';
    }
})();

var BACK_BTN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 183.192 145"><path d="m96.127 145 .137-47.578h86.928V47.578H96.264L96.127 0 0 72.5z" style="fill:#fff"/></svg>';
var FORWARD_BTN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="183.2" height="145" viewBox="0 0 183.2 145"><path d="m87.1 0-.2 47.6H0v49.8h86.9l.2 47.6 96.1-72.5z" style="fill:#2c2c2c"/></svg>';

var MODAL_BACK_SVG = '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 375.8 521.5"><path d="M332.7 0H34C15.4 0 0 17 0 37.9v483.6l146.2-141.3 146.2 141.3V49a27 27 0 0 1 15.7-25c15-6.3 25 15.9 10.3 23a51 51 0 0 1-10.1 3.5v31.2H374S388.7 0 332.7 0m-99.5 225v24.8h-87v47.6L50 225l96.1-72.5.2 47.6h87z" style="fill:#2c2c2c"/></svg>';
var MODAL_INFO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 375.8 521.5"><path d="M332.7 0H34C15.4 0 0 17 0 37.9v483.6l146.2-141.3 146.2 141.3V49a27 27 0 0 1 15.7-25c15-6.3 25 15.9 10.3 23a51 51 0 0 1-10.1 3.5v31.2H374S388.7 0 332.7 0m-173 298.5q-6 5.8-14.3 5.8t-14.5-5.8q-6-6-6.1-14t6.1-14 14.5-6a20 20 0 0 1 14.3 6 19 19 0 0 1 0 28m29.9-73.2a64 64 0 0 1-39.3 15.3l-.7 14.5h-9.5v-41.5a38 38 0 0 0 24.3-9.8 31 31 0 0 0 8.7-23.1q0-11.7-6.1-18.6t-16.5-7q-4.4 0-7.8.9-3.5.9-6.6 2.8l2.5 8.8q1.5 5.5 1.4 10 0 7.5-4.8 11.6a20 20 0 0 1-13.5 4q-8.1 0-12.8-5a18 18 0 0 1-4.6-12.6q0-12.3 14-20.8a64 64 0 0 1 33.7-8.6q23.4 0 37.8 12.2a40 40 0 0 1 14.5 32.1q0 21.5-14.7 34.8" style="fill:#2c2c2c"/></svg>';

function bindHistoryBack(ids, fn) {
    for (var i = 0; i < ids.length; i++) bindButton(ids[i], fn);
}
function bindHistoryForward(ids, fn) {
    for (var i = 0; i < ids.length; i++) bindButton(ids[i], fn);
}

function updateHistoryButtons(backIds, forwardIds, historyIndex, historyLength, opts) {
    opts = opts || {};
    var isGameOver = opts.isGameOver || false;
    for (var i = 0; i < backIds.length; i++) {
        var el = document.getElementById(backIds[i]);
        if (el) {
            el.disabled = historyIndex <= 0;
            el.innerHTML = BACK_BTN_SVG;
        }
    }
    for (var i = 0; i < forwardIds.length; i++) {
        var btn = document.getElementById(forwardIds[i]);
        if (!btn) continue;
        if (isGameOver && historyIndex === historyLength - 1) {
            btn.disabled = false;
            btn.innerHTML = 'New';
            btn.classList.add('btn-new');
        } else {
            btn.disabled = historyIndex >= historyLength - 1;
            btn.innerHTML = FORWARD_BTN_SVG;
            btn.classList.remove('btn-new');
        }
    }
}

function isKindle() { return /Kindle|Silk/i.test(navigator.userAgent); }
function refreshEink() {
    if (!isKindle()) return;
    var overlay = document.getElementById(window._einkOverlayId || 'eink-refresh-overlay');
    if (!overlay) return;
    setTimeout(function() {
        overlay.style.display = 'block';
        overlay.style.backgroundColor = '#000';
        setTimeout(function() {
            overlay.style.backgroundColor = '#fff';
            setTimeout(function() {
                overlay.style.display = 'none';
                overlay.style.backgroundColor = '#000';
            }, 100);
        }, 300);
    }, 100);
}

var isFullscreenMode = false;
var _onFullscreenExit;
var _fullscreenListenersAdded = false;

function toggleFullscreenMode(afterCallback) {
    isFullscreenMode = !isFullscreenMode;
    if (isFullscreenMode) {
        document.body.classList.add('fullscreen-mode');
        var elem = document.documentElement;
        var req = elem.requestFullscreen || elem.webkitRequestFullscreen || elem.webkitRequestFullScreen || elem.mozRequestFullScreen || elem.msRequestFullscreen;
        if (req) req.call(elem).catch(function() {});
    } else {
        document.body.classList.remove('fullscreen-mode');
        var exit = document.exitFullscreen || document.webkitExitFullscreen || document.webkitCancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen;
        if (exit && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement)) exit.call(document).catch(function() {});
    }
    if (afterCallback) afterCallback();
}

function handleFullscreenChange() {
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
        if (isFullscreenMode) {
            isFullscreenMode = false;
            document.body.classList.remove('fullscreen-mode');
            if (_onFullscreenExit) _onFullscreenExit();
        }
    }
}

function initFullscreen(onExit) {
    _onFullscreenExit = onExit;
    if (!_fullscreenListenersAdded) {
        _fullscreenListenersAdded = true;
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    }
}

var _doubleTapLastTime = 0;
function initDoubleTapFullscreen(containerSelector) {
    containerSelector = containerSelector || '.board-container';
    initFullscreen(refreshEink);
    function handleTap(e) {
        var container = document.querySelector(containerSelector);
        if (!container) return;
        var outside = !container.contains(e.target);
        var isBtn = e.target.classList && (e.target.classList.contains('btn') || (e.target.closest && e.target.closest('.btn')));
        var isModalOrLink = e.target.closest && (e.target.closest('.promotion-modal') || e.target.closest('a'));
        if (!outside || isBtn || isModalOrLink) return;
        var now = Date.now();
        if (now - _doubleTapLastTime < 500) {
            toggleFullscreenMode(refreshEink);
            _doubleTapLastTime = 0;
        } else {
            _doubleTapLastTime = now;
        }
    }
    document.addEventListener('touchstart', function(e) {
        var container = document.querySelector(containerSelector);
        if (!container) return;
        var outside = !container.contains(e.target);
        var isBtn = e.target.classList && (e.target.classList.contains('btn') || (e.target.closest && e.target.closest('.btn')));
        var isModalOrLink = e.target.closest && (e.target.closest('.promotion-modal') || e.target.closest('a'));
        if (outside && !isBtn && !isModalOrLink) {
            e.preventDefault();
            handleTap(e);
        }
    }, { passive: false });
    document.addEventListener('click', handleTap);
}

function registerServiceWorker(path) {
    path = path || '../sw.js';
    if ('serviceWorker' in navigator) navigator.serviceWorker.register(path).catch(function() {});
}

function runOnReady(fn) {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn);
    else fn();
}

function bindButton(el, fn) {
    if (typeof el === 'string') el = document.getElementById(el);
    if (!el) return;
    el.onclick = fn;
    el.addEventListener('touchstart', function(e) { e.preventDefault(); fn.call(el); }, { passive: false });
}
function bindCell(el, handler) {
    if (!el) return;
    el.addEventListener('touchstart', function(e) { e.preventDefault(); handler.call(el, e); }, { passive: false });
    el.onclick = handler;
}
function bindOptions(selector, fn) {
    var els = document.querySelectorAll(selector);
    for (var i = 0; i < els.length; i++) bindButton(els[i], fn);
}

function showModal(elOrId) {
    var el = typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId;
    if (!el) return;
    el.classList.add('show');
    el.setAttribute('aria-hidden', 'false');
}

function hideModal(elOrId) {
    var el = typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId;
    if (!el) return;
    el.classList.remove('show');
    el.setAttribute('aria-hidden', 'true');
}

function bindModal(modalId, openBtnId, closeBtnId) {
    var modal = document.getElementById(modalId);
    var openBtn = document.getElementById(openBtnId);
    var closeBtn = document.getElementById(closeBtnId);
    if (openBtn) bindButton(openBtn, function() { showModal(modal); });
    if (closeBtn) bindButton(closeBtn, function() { hideModal(modal); });
    if (modal) modal.onclick = function(e) { if (e.target === modal) hideModal(modal); };
}

var _welcomeContinueOpts = null;window._welcomeHandlers=window._welcomeHandlers||{};if(!window._welcomeDelegationBound){window._welcomeDelegationBound=true;document.addEventListener('click',function(e){var id=e.target&&e.target.id;if(id&&window._welcomeHandlers[id]){var fn=window._welcomeHandlers[id];if(typeof fn==='function')fn.call(e.target);}});document.addEventListener('touchstart',function(e){var id=e.target&&e.target.id;if(id&&window._welcomeHandlers[id]){var fn=window._welcomeHandlers[id];if(typeof fn==='function'){e.preventDefault();fn.call(e.target);}}},{passive:false});}
function updateWelcomeContinueButton() {
    if (!_welcomeContinueOpts || !_welcomeContinueOpts.btnId || typeof _welcomeContinueOpts.hasSave !== 'function') return;
    var btn = document.getElementById(_welcomeContinueOpts.btnId);
    if (btn) btn.disabled = !_welcomeContinueOpts.hasSave();
}
function showWelcome(modalId, footerId) {
    var modal = document.getElementById(modalId);
    var footer = footerId ? document.getElementById(footerId) : null;
    if (modal) modal.style.display = 'flex';
    if (footer) footer.style.display = 'block';
    updateWelcomeContinueButton();
}

function hideWelcome(modalId, footerId) {
    var modal = document.getElementById(modalId);
    var footer = footerId ? document.getElementById(footerId) : null;
    if (modal) modal.style.display = 'none';
    if (footer) footer.style.display = 'none';
}

function runWelcomeFlow(opts) {
    if (opts.continueBtnId) { _welcomeContinueOpts = { btnId: opts.continueBtnId, hasSave: opts.hasSave }; window._welcomeHandlers[opts.continueBtnId] = function() { if (this.disabled) return; opts.onContinue(); }; }
    showWelcome(opts.modalId, opts.footerId);
    if (opts.newButtons) { for (var i = 0; i < opts.newButtons.length; i++) window._welcomeHandlers[opts.newButtons[i].id] = opts.newButtons[i].fn; }
    if (opts.infoModal) { var _m = document.getElementById(opts.infoModal.modalId); if (_m) { _m.onclick = function(e) { if (e.target === _m) hideModal(_m); }; window._welcomeHandlers[opts.infoModal.openBtnId] = function() { showModal(_m); }; window._welcomeHandlers[opts.infoModal.closeBtnId] = function() { hideModal(_m); }; } }
}

var _backToWelcomeBound = false;
function initBackToWelcome(modalId, footerId) {
    if (history.replaceState) history.replaceState({ step: 'welcome' }, '', location.href);
    if (!_backToWelcomeBound) {
        _backToWelcomeBound = true;
        window.addEventListener('popstate', function(e) {
            if (e.state && e.state.step === 'welcome') showWelcome(modalId, footerId);
        });
    }
}
function pushStatePlaying() {
    if (history.pushState) history.pushState({ step: 'playing' }, '', location.href);
}

function initModalSvgs() {
    var backLinks = document.querySelectorAll('.welcome-back-link');
    for (var i = 0; i < backLinks.length; i++) backLinks[i].innerHTML = MODAL_BACK_SVG;
    var infoBtns = document.querySelectorAll('.welcome-variants-info-btn');
    for (var i = 0; i < infoBtns.length; i++) infoBtns[i].innerHTML = MODAL_INFO_SVG;
}
function initNavSvgs() {
    var backBtns = document.querySelectorAll('.btn-nav-back');
    for (var i = 0; i < backBtns.length; i++) backBtns[i].innerHTML = BACK_BTN_SVG;
    var fwdBtns = document.querySelectorAll('.btn-nav-forward');
    for (var i = 0; i < fwdBtns.length; i++) fwdBtns[i].innerHTML = FORWARD_BTN_SVG;
}
function initPageSvgs() {
    initModalSvgs();
    initNavSvgs();
}
if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initPageSvgs);
else initPageSvgs();

function startNewGame() {
            board = [
                ['bR','bN','bB','bQ','bK','bB','bN','bR'],
                ['bP','bP','bP','bP','bP','bP','bP','bP'],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['wP','wP','wP','wP','wP','wP','wP','wP'],
                ['wR','wN','wB','wQ','wK','wB','wN','wR']
            ];
            currentTurn = 'w';
            gameHistory = [];
            historyIndex = -1;
            capturedPieces = {w: [], b: []};
            lastMove = null;
            enPassantTarget = null;
            castlingRights = {w: {k: true, q: true}, b: {k: true, q: true}};
            halfMoveClock = 0;
            isGameOver = false;
            pendingPromotion = null;
            statsSent = false;
            gameStartTime = Date.now();

            clearSavedGame();
            initBoard();
            saveState();
            renderBoard();
            refreshEink();
            
            if (typeof gtag === 'function') gtag('event', 'game_start', { 'method': 'manual' });
        }

        var pieceSymbols = {};
        var pieceValues = {'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 0};
        var KNIGHT_OFFSETS = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        var KING_OFFSETS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        var PIECE_OFFSETS = {
            'B': [[-1,-1],[-1,1],[1,-1],[1,1]],
            'R': [[-1,0],[1,0],[0,-1],[0,1]],
            'Q': [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]
        };

        var board;

        var currentTurn = 'w';
        var selectedSquare = null;
        var gameHistory = [];
        var historyIndex = -1;
        var capturedPieces = {w: [], b: []};
        var lastMove = null;
        var enPassantTarget = null;
        var castlingRights = {w: {k: true, q: true}, b: {k: true, q: true}};
        var halfMoveClock = 0;
        var isGameOver = false;
        var pendingPromotion = null;
        var hasAutoSaved = false;

        var boardElement = document.getElementById('chess-board');
        var statusElements = [document.getElementById('chess-status'), document.getElementById('chess-statusBottom')];
        var scoreElements = [document.getElementById('chess-scoreTop'), document.getElementById('chess-scoreBottom')];
        var promotionModal = document.getElementById('chess-promotionModal');
        var squareElements = [];

        var isRotationLocked = localStorage.getItem('chessRotationLocked') === 'true';
        var lastClickTime = 0;
        var lastClickSquare = null;

        function saveGame() {
            var gameData = {
                board: board,
                currentTurn: currentTurn,
                capturedPieces: capturedPieces,
                lastMove: lastMove,
                enPassantTarget: enPassantTarget,
                castlingRights: castlingRights,
                halfMoveClock: halfMoveClock,
                gameHistory: gameHistory,
                historyIndex: historyIndex,
                isGameOver: isGameOver,
                timestamp: new Date().toISOString()
            };
            saveJSON('chessGameSave', gameData);
        }

        function loadGame() {
            var data = loadJSON('chessGameSave');
            if (!data) return false;
            board = data.board;
            currentTurn = data.currentTurn;
            capturedPieces = data.capturedPieces;
            lastMove = data.lastMove;
            enPassantTarget = data.enPassantTarget;
            castlingRights = data.castlingRights;
            halfMoveClock = data.halfMoveClock;
            gameHistory = data.gameHistory;
            historyIndex = data.historyIndex;
            isGameOver = data.isGameOver;
            renderBoard();
            return true;
        }

        function clearSavedGame() {
            clearSaved('chessGameSave');
        }


        function getBoardHash(b, turn, cast, ep) {
            var s = "";
            for (var i = 0; i < 8; i++) s += b[i].join(",") + "/";
            s += "|" + turn + "|" + cast.w.k + cast.w.q + cast.b.k + cast.b.q;
            if (ep) s += "|" + ep.row + "," + ep.col;
            return s;
        }

        (function initPieceSymbols() {
        var rawSvgs = {
            'P': '<svg viewBox="-10 -10 310.789 389.771"><path style="fill:#454242" stroke="#fff" stroke-width="10" d="M289.604 369.771H.808c-3.901-32.071 7.231-51.733 13.937-63.617 8.371-14.712 18.978-22.513 31.295-31.523 11.085-8.143 23.677-17.381 36.017-33.28 13.002-16.788 22.285-36.428 27.623-58.371l-3.33-4.22H71.291a7.736 7.736 0 0 1-7.505-5.862l-3.809-15.283c-.73-4.676 1.574-9.306 5.771-11.565l35.173-19.115.57-5.634c-15.488-13.07-24.361-32.23-24.361-52.508C77.13 30.862 107.992 0 145.925 0c37.933 0 68.795 30.862 68.795 68.795 0 21.008-9.398 40.579-25.798 53.695l.593 5.725 32.869 16.719c4.676 2.372 7.117 7.778 5.771 12.933l-3.627 14.986c-.821 3.467-3.923 5.908-7.505 5.908h-30.725l-3.376 3.946c3.262 20.643 10.378 39.119 21.145 54.972 12.637 18.613 27.212 28.832 40.054 37.842 12.979 9.101 25.205 17.678 33.713 33.485 6.182 11.542 16.446 30.611 11.77 60.765z"/></svg>',
            'N': '<svg viewBox="-10 -10 386.486 461.672"><path style="fill:#454242" stroke="#fff" stroke-width="10" d="M108.666 316.423c12.568-20.506 29.448-34.26 45.825-47.581 11.975-9.74 23.289-18.932 32.048-30.223 12.386-15.921 11.542-33.667 6.615-44.981a62.62 62.62 0 0 1-.798-1.962c-.775-2.03-1.209-2.714-3.239-4.425a4.996 4.996 0 0 0-3.125-1.118 4.931 4.931 0 0 0-3.513 1.506c-3.764 3.992-37.294 39.073-54.196 43.293-6.455 1.597-11.838 1.391-16.583 1.186-8.622-.342-16.081-.639-22.696 10.972-6.318 11.04-13.481 18.522-17.176 22.012a8.609 8.609 0 0 1-5.109 2.327c-27.303 2.6-45.916-10.014-57.549-19.731-12.91-10.743-8.576-24.475-8.052-25.958 1.437-3.467 27.805-50.592 39.142-57.093 13.572-7.733 31.774-65.077 33.736-74.931 2.098-10.47 19.936-25.843 31.774-36.04l1.255-1.095c6.752-5.839 7.322-12.933 7.892-19.845.661-7.961 1.346-16.172 9.808-25.798 3.148-3.604 7.824-7.687 12.158-6.82 5.201 1.049 8.052 8.508 8.348 9.352l.251.707 28.261 28.763c2.943 2.965 6.797 4.813 10.835 5.201 23.266 2.395 61.929 16.492 90.783 38.8 37.18 28.741 59.762 66.97 69.046 116.832 9.557 51.414-11.108 128.534-17.267 149.702-123.721-18.362-212.679-5.36-233.071-1.802 1.846-10.174 10.788-25.457 14.597-31.25z"/><path style="fill:#454242" stroke="#fff" stroke-width="10" d="M366.486 433.278c0 4.63-3.764 8.394-8.394 8.394H56.819c-4.63 0-8.394-3.764-8.394-8.394v-23.973c0-25.821 17.541-48.083 42.677-54.128 2.692-.547 98.037-19.685 237.611 1.437 22.605 7.687 37.773 28.832 37.773 52.691v23.973z"/><path style="fill:#fff" d="M122.43 102.104s-8.541 10.677-11.259 23.489c0 0 7.619-5.023 27.76-2.524 20.335 2.524 17.86-20.529 10.483-25.431-3.329-2.211-15.142-9.123-26.984 4.466z"/></svg>',
            'B': '<svg viewBox="-10 -10 336.966 466.595"><path style="fill:#454242" stroke="#fff" stroke-width="10" d="m40.579 192.196.16-.73c6.113-52.851 73.037-113.091 86.404-124.633l.433-3.513a38.117 38.117 0 0 1-9.534-25.205C118.041 17.107 135.126 0 156.134 0s38.115 17.108 38.115 38.116c0 15.67-9.831 29.972-24.475 35.561l-1.232.912c-30.976 49.315-32.641 155.678-32.709 160.171l-.046 3.536 52.006-.274-.045-3.376c-.958-83.416 21.053-129.469 28.33-141.946 77.941 85.446 70.756 128.42 70.665 128.808l-.068.388v.411c1.711 65.715-29.219 110.263-44.388 128.055a1005.352 1005.352 0 0 0-87.704-3.558c-25.775.114-51.801 1.3-77.554 3.421-64.187-73.746-36.747-157.208-36.45-158.029zM316.966 443.607a2.999 2.999 0 0 1-2.988 2.988H2.988A2.999 2.999 0 0 1 0 443.607v-19.571c0-36.427 29.63-66.058 66.057-66.058l.319-.023a990.753 990.753 0 0 1 88.229-4.311c31.934-.114 64.21 1.323 95.984 4.311l.319.023c36.427 0 66.057 29.63 66.057 66.058v19.571z"/></svg>',
            'R': '<svg viewBox="-10 -10 345.497 428.594"><path style="fill:#454242" stroke="#fff" stroke-width="10" d="m29.128 87.43-5.292-52.189a22.465 22.465 0 0 1 5.702-17.336 22.4 22.4 0 0 1 16.651-7.413h28.626c4.881 0 9.17 3.262 10.47 7.961l11.223 40.465 22.171-.798 2.053-51.414A6.97 6.97 0 0 1 127.712 0h65.624a6.944 6.944 0 0 1 6.934 6.295l5.201 52.029 26.414-.753 6.09-37.933c.844-5.315 5.361-9.147 10.721-9.147h25.57a22.485 22.485 0 0 1 16.674 7.413 22.535 22.535 0 0 1 5.68 17.336l-5.269 51.847-.023.342c0 25.73-20.917 46.669-46.646 46.669H75.774c-25.729.001-46.646-20.938-46.646-46.668zM68.315 140.418c2.441.342 4.927.525 7.459.525h168.907c3.308 0 6.524-.319 9.671-.89l22.194 174.564a64.99 64.99 0 0 0-9.945-.753H58.895c-3.421 0-6.775.251-10.036.775l19.456-174.221zM325.497 408.594H0v-28.991c0-32.481 26.414-58.895 58.895-58.895h207.707c32.481 0 58.895 26.414 58.895 58.895v28.991z"/></svg>',
            'Q': '<svg viewBox="-10 -10 456.331 458.452"><path style="fill:#454242" stroke="#fff" stroke-width="10" d="M374.812 393.243c.639 3.034.958 6.227.958 9.603v35.606H58.804v-35.606c0-22.263 15.876-38.07 49.977-49.748 16.309-5.588 65.989-10.31 108.507-10.31 38.275 0 77.827 1.255 107.914 10.356 30.017 9.054 45.755 21.646 49.61 40.099z"/><path style="fill:#454242" stroke="#fff" stroke-width="10" d="m398.238 177.119-2.691 2.144-66.697 167.835c-.57-.182-1.118-.342-1.665-.525-30.953-9.329-71.099-10.63-109.898-10.63-41.446 0-88.069 4.288-107.571 9.717l-64.94-166.604-3.011-2.19C18.339 175.568 0 156.134 0 132.64c0-24.452 19.89-44.343 44.32-44.343 24.452 0 44.342 19.89 44.342 44.343 0 8.713-2.509 17.107-7.276 24.293l.342 4.22 48.197 51.938a3.974 3.974 0 0 0 2.943 1.277 4 4 0 0 0 4.037-3.901l3.079-121.736-2.144-3.262c-16.88-6.774-27.783-22.947-27.783-41.149 0-24.429 19.89-44.32 44.32-44.32 24.452 0 44.342 19.89 44.342 44.32 0 13.161-5.794 25.547-15.899 34.009l-1.072 3.673 32.892 101.185a3.97 3.97 0 0 0 3.809 2.783c1.734 0 3.285-1.095 3.809-2.76l33.508-101.641-1.004-3.673a44.166 44.166 0 0 1-15.419-33.576c0-24.429 19.89-44.32 44.32-44.32 24.452 0 44.342 19.89 44.342 44.32 0 18.978-12.066 35.857-29.995 41.97l-2.327 3.422 6.638 117.334a3.98 3.98 0 0 0 2.715 3.581c.433.16.867.228 1.3.228a4.07 4.07 0 0 0 3.056-1.414l43.362-50.957.388-3.855c-3.581-6.501-5.475-13.914-5.475-21.396 0-24.452 19.89-44.342 44.32-44.342 24.452 0 44.342 19.89 44.342 44.342.002 21.966-16.376 40.852-38.091 43.886z"/></svg>',
            'K': '<svg viewBox="-10 -10 440.106 473.415"><path style="fill:#454242" stroke="#fff" stroke-width="10" d="m400.114 153.397-.159-.183c-46.464-59.192-122.079-32.481-144.159-22.878a9.24 9.24 0 0 1-7.801-.228 9.198 9.198 0 0 1-4.858-6.113l-8.668-36.108h36.633V39.598H233.83V0h-47.558v39.598h-37.271v48.289h36.633l-8.668 36.108a9.2 9.2 0 0 1-4.859 6.113 9.24 9.24 0 0 1-7.801.228c-22.08-9.603-97.695-36.313-144.159 22.878l-.16.183c-2.121 2.349-51.459 58.713 13.253 139.118l63.662 68.749c.981-.251 2.008-.433 3.034-.639.662-.137 1.323-.297 2.007-.41a93.347 93.347 0 0 1 6.387-.958l4.266-.479c27.965-3.079 59.648-6.569 94.889-6.683h2.122c2.783 0 5.566.046 8.326.068.958.023 1.916.023 2.874.023a723.573 723.573 0 0 1 63.617 3.832l.798.069c3.695.388 7.368.821 11.063 1.277.593.068 1.209.137 1.825.205 4.243.525 8.485 1.095 12.728 1.711 2.235.319 4.402.707 6.546 1.163.685.137 1.346.297 2.03.456 1.026.251 2.098.456 3.102.73l64.37-69.114c64.687-80.406 15.349-136.769 13.228-139.118zM169.802 284.804c-.046 5.657-4.676 10.264-10.333 10.264h-4.721c-12.112 0-23.563-4.722-32.231-13.321-17.267-17.085-37.499-42.769-35.697-67.996.502-6.638 4.585-13.093 11.245-17.723 9.535-6.592 30.702-14.37 65.373 7.596 4.151 2.646 6.707 7.345 6.684 12.272l-.32 68.908zm126.96-3.033c-4.334 4.288-9.352 7.618-14.826 9.854a45.578 45.578 0 0 1-17.427 3.444h-4.699c-5.657 0-10.31-4.608-10.333-10.264l-.32-68.909c-.023-4.95 2.509-9.626 6.661-12.272 34.717-21.966 55.839-14.188 65.35-7.596 6.683 4.63 10.789 11.086 11.291 17.723 1.803 25.228-18.407 50.912-35.697 68.02z"/><path style="fill:#454242" stroke="#fff" stroke-width="10" d="M369.48 425.177v21.761a6.474 6.474 0 0 1-6.478 6.478H56.072a6.474 6.474 0 0 1-6.478-6.478v-21.761c0-27.303 18.043-49.064 47.08-56.797 3.9-1.049 8.075-1.825 12.409-2.327l4.265-.456c27.783-3.079 59.283-6.546 94.159-6.66h2.099c33.485 0 67.198 2.395 100.272 7.094 4.471.661 8.759 1.574 12.796 2.737 29.311 8.417 46.806 29.516 46.806 56.409z"/></svg>'
        };

        var types = ['P', 'N', 'B', 'R', 'Q', 'K'];
        for (var i = 0; i < types.length; i++) {
            var type = types[i];
            var svg = rawSvgs[type];
            
            var whiteSvg = svg
            .replace(/fill:#fff/g, "fill:" + PIECE_WHITE_STROKE)
            .replace(/stroke="#fff"/g, 'stroke="' + PIECE_WHITE_STROKE + '"')
            .replace(/fill:#454242/g, "fill:" + PIECE_WHITE_FILL);

            var blackSvg = svg.replace(/fill:#454242/g, "fill:" + PIECE_BLACK_FILL).replace(/stroke="#fff"/g, 'stroke="' + PIECE_BLACK_STROKE + '"');

            pieceSymbols['w' + type] = whiteSvg;
            pieceSymbols['b' + type] = blackSvg;
        }
        })();

        function initBoard() {
            boardElement.innerHTML = '';
            squareElements = [];

            for (var row = 0; row < 8; row++) {
                for (var col = 0; col < 8; col++) {
                    var square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.classList.add('rank' + (8 - row));
                    square.classList.add('file' + (col + 1));
                    square.dataset.row = row;
                    square.dataset.col = col;
                    bindCell(square, handleSquareClick);

                    var pieceContainer = document.createElement('div');
                    pieceContainer.className = 'piece';
                    square.appendChild(pieceContainer);

                    boardElement.appendChild(square);
                    squareElements.push(square);
                }
            }
        }

        function renderBoard() {
            if (isRotationLocked) {
                boardElement.className = 'board rotation-locked';
            } else {
                boardElement.className = currentTurn === 'b' ? 'board black-turn' : 'chess-board';
            }

            var kingPos = findKing(board, currentTurn);
            var checkPos = null;
            if (kingPos && isSquareAttacked(board, kingPos.row, kingPos.col, currentTurn === 'w' ? 'b' : 'w')) {
                checkPos = kingPos;
            }

            for (var row = 0; row < 8; row++) {
                for (var col = 0; col < 8; col++) {
                    var idx = row * 8 + col;
                    var sqEl = squareElements[idx];
                    var pieceCont = sqEl.querySelector('.piece');
                    var piece = board[row][col];
                    
                    sqEl.classList.remove('selected', 'possible-move', 'possible-capture', 'check', 'last-move');
                    

                    if (lastMove) {
                        if ((lastMove.from.row === row && lastMove.from.col === col) || 
                            (lastMove.to.row === row && lastMove.to.col === col)) {
                            sqEl.classList.add('last-move');
                        }
                    }

                    if (checkPos && checkPos.row === row && checkPos.col === col) {
                        sqEl.classList.add('check');
                    }

                    var newContent = piece ? pieceSymbols[piece] : '';
                    if (pieceCont.getAttribute('data-piece') !== (piece || 'empty')) {
                        pieceCont.innerHTML = newContent;
                        pieceCont.setAttribute('data-piece', piece || 'empty');
                    }
                }
            }

            updateCapturedPieces();
            updateStatus();
            updateButtons();
        }

        function handleSquareClick(e) {
            if (isGameOver) return;

            var row = +e.currentTarget.dataset.row;
            var col = +e.currentTarget.dataset.col;
            var now = Date.now();

            if (board[row][col] === '') {
                if (lastClickSquare && lastClickSquare.row === row && lastClickSquare.col === col) {
                    if (now - lastClickTime < 500) {
                        isRotationLocked = !isRotationLocked;
                        
                        localStorage.setItem('chessRotationLocked', isRotationLocked);
                        
                        renderBoard();
                        lastClickTime = 0;
                        lastClickSquare = null;
                        return;
                    }
                }
            }
            
            lastClickTime = now;
            lastClickSquare = {row: row, col: col};

            if (selectedSquare) {
                var moves = getPossibleMoves(selectedSquare.row, selectedSquare.col);
                var valid = false;
                for (var i = 0; i < moves.length; i++) {
                    if (moves[i].row === row && moves[i].col === col) {
                        valid = true;
                        break;
                    }
                }
                
                if (valid) {
                    var piece = board[selectedSquare.row][selectedSquare.col];
                    if (piece[1] === 'P' && (row === 0 || row === 7)) {
                        pendingPromotion = {from: selectedSquare, to: {row: row, col: col}};
                        showPromotionModal();
                    } else {
                        makeMove(selectedSquare.row, selectedSquare.col, row, col);
                        clearSelection();
                    }
                } else if (board[row][col] && board[row][col][0] === currentTurn) {
                    selectSquare(row, col);
                } else {
                    clearSelection();
                }
            } else {
                if (board[row][col] && board[row][col][0] === currentTurn) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            selectedSquare = {row: row, col: col};
            renderBoard();
            
            squareElements[row * 8 + col].classList.add('selected');

            var moves = getPossibleMoves(row, col);
            for (var i = 0; i < moves.length; i++) {
                var m = moves[i];
                var sq = squareElements[m.row * 8 + m.col];
                
                var isCapture = board[m.row][m.col];
                var piece = board[row][col];
                
                if (!isCapture && piece && piece[1] === 'P' && m.col !== col && 
                    enPassantTarget && enPassantTarget.row === m.row && enPassantTarget.col === m.col) {
                    isCapture = true;
                }
                
                sq.classList.add(isCapture ? 'possible-capture' : 'possible-move');
            }
        }

        function clearSelection() {
            selectedSquare = null;
            renderBoard();
        }

        function findKing(b, color) {
            for (var r = 0; r < 8; r++) {
                for (var c = 0; c < 8; c++) {
                    var p = b[r][c];
                    if (p && p[0] === color && p[1] === 'K') return {row: r, col: c};
                }
            }
            return null;
        }

        function isSquareAttacked(b, row, col, attacker) {
            var pDir = attacker === 'w' ? -1 : 1;
            var aRow = row - pDir;
            if (aRow >= 0 && aRow < 8) {
                for (var dc = -1; dc <= 1; dc += 2) {
                    var c = col + dc;
                    if (c >= 0 && c < 8) {
                        var p = b[aRow][c];
                        if (p && p[0] === attacker && p[1] === 'P') return true;
                    }
                }
            }

            for (var i = 0; i < KNIGHT_OFFSETS.length; i++) {
                var r = row + KNIGHT_OFFSETS[i][0], c = col + KNIGHT_OFFSETS[i][1];
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    var p = b[r][c];
                    if (p && p[0] === attacker && p[1] === 'N') return true;
                }
            }

            var dirs = PIECE_OFFSETS['B'];
            for (var i = 0; i < dirs.length; i++) {
                var dr = dirs[i][0], dc = dirs[i][1];
                var r = row + dr, c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    var p = b[r][c];
                    if (p) {
                        if (p[0] === attacker && (p[1] === 'B' || p[1] === 'Q')) return true;
                        break;
                    }
                    r += dr; c += dc;
                }
            }
            
            dirs = PIECE_OFFSETS['R'];
            for (var i = 0; i < dirs.length; i++) {
                var dr = dirs[i][0], dc = dirs[i][1];
                var r = row + dr, c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    var p = b[r][c];
                    if (p) {
                        if (p[0] === attacker && (p[1] === 'R' || p[1] === 'Q')) return true;
                        break;
                    }
                    r += dr; c += dc;
                }
            }

            for (var i = 0; i < KING_OFFSETS.length; i++) {
                var r = row + KING_OFFSETS[i][0], c = col + KING_OFFSETS[i][1];
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    var p = b[r][c];
                    if (p && p[0] === attacker && p[1] === 'K') return true;
                }
            }

            return false;
        }

        function getPossibleMoves(row, col) {
            var piece = board[row][col];
            if (!piece) return [];

            var color = piece[0], type = piece[1];
            var pseudo = [];

            if (type === 'P') {
                var dir = color === 'w' ? -1 : 1;
                var start = color === 'w' ? 6 : 1;
                
                if (!board[row + dir][col]) {
                    pseudo.push({row: row + dir, col: col});
                    if (row === start && !board[row + 2 * dir][col]) {
                        pseudo.push({row: row + 2 * dir, col: col});
                    }
                }
                
                for (var dc = -1; dc <= 1; dc += 2) {
                    var c = col + dc;
                    if (c >= 0 && c < 8) {
                        var target = board[row + dir][c];
                        if (target && target[0] !== color) {
                            pseudo.push({row: row + dir, col: c});
                        }
                        if (enPassantTarget && enPassantTarget.row === row + dir && enPassantTarget.col === c) {
                            pseudo.push({row: row + dir, col: c});
                        }
                    }
                }
            } else if (type === 'N') {
                for (var i = 0; i < KNIGHT_OFFSETS.length; i++) {
                    var nr = row + KNIGHT_OFFSETS[i][0], nc = col + KNIGHT_OFFSETS[i][1];
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        if (!board[nr][nc] || board[nr][nc][0] !== color) {
                            pseudo.push({row: nr, col: nc});
                        }
                    }
                }
            } else if (type === 'B' || type === 'R' || type === 'Q') {
                var dirs = PIECE_OFFSETS[type];
                for (var i = 0; i < dirs.length; i++) {
                    var dr = dirs[i][0], dc = dirs[i][1];
                    var nr = row + dr, nc = col + dc;
                    while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        if (!board[nr][nc]) {
                            pseudo.push({row: nr, col: nc});
                        } else {
                            if (board[nr][nc][0] !== color) pseudo.push({row: nr, col: nc});
                            break;
                        }
                        nr += dr; nc += dc;
                    }
                }
            } else if (type === 'K') {
                for (var i = 0; i < KING_OFFSETS.length; i++) {
                    var nr = row + KING_OFFSETS[i][0], nc = col + KING_OFFSETS[i][1];
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        if (!board[nr][nc] || board[nr][nc][0] !== color) {
                            pseudo.push({row: nr, col: nc});
                        }
                    }
                }

                var sRow = color === 'w' ? 7 : 0;
                if (row === sRow && col === 4) {
                    var rights = castlingRights[color];
                    var opp = color === 'w' ? 'b' : 'w';
                    if (rights.k && !board[row][5] && !board[row][6] && 
                        !isSquareAttacked(board, row, 4, opp) &&
                        !isSquareAttacked(board, row, 5, opp) &&
                        !isSquareAttacked(board, row, 6, opp) &&
                        board[row][7] === color + 'R') {
                        pseudo.push({row: row, col: 6, isCastling: 'k'});
                    }
                    if (rights.q && !board[row][3] && !board[row][2] && !board[row][1] &&
                        !isSquareAttacked(board, row, 4, opp) &&
                        !isSquareAttacked(board, row, 3, opp) &&
                        !isSquareAttacked(board, row, 2, opp) &&
                        board[row][0] === color + 'R') {
                        pseudo.push({row: row, col: 2, isCastling: 'q'});
                    }
                }
            }

            var legal = [];
            for (var i = 0; i < pseudo.length; i++) {
                var m = pseudo[i];
                var orig = board[row][col];
                var targ = board[m.row][m.col];
                var epCap = null;
                
                if (orig[1] === 'P' && m.col !== col && !targ) {
                    epCap = {row: row, col: m.col, piece: board[row][m.col]};
                    board[row][m.col] = '';
                }

                board[m.row][m.col] = orig;
                board[row][col] = '';

                var kPos = findKing(board, color);
                if (kPos && !isSquareAttacked(board, kPos.row, kPos.col, color === 'w' ? 'b' : 'w')) {
                    legal.push(m);
                }

                board[row][col] = orig;
                board[m.row][m.col] = targ;
                if (epCap) board[epCap.row][epCap.col] = epCap.piece;
            }

            return legal;
        }

        function makeMove(fr, fc, tr, tc, promo) {
            var piece = board[fr][fc];
            var captured = board[tr][tc];
            
            halfMoveClock = (piece[1] === 'P' || captured) ? 0 : halfMoveClock + 1;
            enPassantTarget = null;
            
            if (piece[1] === 'P' && Math.abs(fr - tr) === 2) {
                enPassantTarget = {row: (fr + tr) / 2, col: fc};
            }
            
            if (captured) capturedPieces[captured[0]].push(captured);
            
            if (piece[1] === 'P' && tc !== fc && !captured) {
                var capPawn = board[fr][tc];
                if (capPawn) {
                    capturedPieces[capPawn[0]].push(capPawn);
                    board[fr][tc] = '';
                }
            }
            
            board[tr][tc] = piece;
            board[fr][fc] = '';
            
            if (piece[1] === 'P' && (tr === 0 || tr === 7)) {
                board[tr][tc] = piece[0] + (promo || 'Q');
            }

            if (piece[1] === 'K' && Math.abs(fc - tc) === 2) {
                if (tc > fc) {
                    board[fr][5] = board[fr][7];
                    board[fr][7] = '';
                } else {
                    board[fr][3] = board[fr][0];
                    board[fr][0] = '';
                }
            }

            var color = piece[0];
            if (piece[1] === 'K') {
                castlingRights[color].k = false;
                castlingRights[color].q = false;
            } else if (piece[1] === 'R') {
                if (fc === 0) castlingRights[color].q = false;
                if (fc === 7) castlingRights[color].k = false;
            }
            
            if (captured && captured[1] === 'R') {
                var enemy = captured[0];
                var enemyHomeRank = (enemy === 'w') ? 7 : 0;
                if (tr === enemyHomeRank) {
                    if (tc === 0) castlingRights[enemy].q = false;
                    if (tc === 7) castlingRights[enemy].k = false;
                }
            }
            
            lastMove = {from: {row: fr, col: fc}, to: {row: tr, col: tc}};
            currentTurn = currentTurn === 'w' ? 'b' : 'w';
            
            saveState();
            renderBoard();
        }

        function cloneBoard(src) {
            var dst = [];
            for (var i = 0; i < 8; i++) dst[i] = src[i].slice();
            return dst;
        }

        function saveState() {
            gameHistory = gameHistory.slice(0, historyIndex + 1);
            var stateHash = getBoardHash(board, currentTurn, castlingRights, enPassantTarget);
            
            gameHistory.push({
                board: cloneBoard(board),
                currentTurn: currentTurn,
                capturedPieces: {w: capturedPieces.w.slice(), b: capturedPieces.b.slice()},
                lastMove: lastMove ? JSON.parse(JSON.stringify(lastMove)) : null,
                enPassantTarget: enPassantTarget ? {row: enPassantTarget.row, col: enPassantTarget.col} : null,
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                halfMoveClock: halfMoveClock,
                hash: stateHash
            });
            historyIndex++;
            if (hasAutoSaved) saveGame();
        }

        function restoreState(idx) {
            if (idx < 0 || idx >= gameHistory.length) return;
            
            var s = gameHistory[idx];
            board = cloneBoard(s.board);
            currentTurn = s.currentTurn;
            capturedPieces = {w: s.capturedPieces.w.slice(), b: s.capturedPieces.b.slice()};
            lastMove = s.lastMove ? {from: {row: s.lastMove.from.row, col: s.lastMove.from.col}, to: {row: s.lastMove.to.row, col: s.lastMove.to.col}} : null;
            enPassantTarget = s.enPassantTarget ? {row: s.enPassantTarget.row, col: s.enPassantTarget.col} : null;
            castlingRights = s.castlingRights ? {
                w: {k: s.castlingRights.w.k, q: s.castlingRights.w.q},
                b: {k: s.castlingRights.b.k, q: s.castlingRights.b.q}
            } : {w: {k: true, q: true}, b: {k: true, q: true}};
            halfMoveClock = s.halfMoveClock !== undefined ? s.halfMoveClock : 0;
            historyIndex = idx;
            isGameOver = false;
            clearSelection();
        }

        function updateCapturedPieces() {
            var wMat = 0, bMat = 0;
            for (var r = 0; r < 8; r++) {
                for (var c = 0; c < 8; c++) {
                    var p = board[r][c];
                    if (p) {
                        var val = pieceValues[p[1]] || 0;
                        if (p[0] === 'w') wMat += val;
                        else bMat += val;
                    }
                }
            }

            var wAdv = wMat - bMat;

            function render(contId, pieces, trophyColor) {
                var cont = document.getElementById(contId);
                if (!cont) return;
                
                var counts = {P: 0, N: 0, B: 0, R: 0, Q: 0};
                for (var i = 0; i < pieces.length; i++) {
                    if (pieces[i][0] === trophyColor) {
                        var t = pieces[i][1];
                        if (counts[t] !== undefined) counts[t]++;
                    }
                }

                var html = '';
                var types = ['P', 'N', 'B', 'R', 'Q'];
                for (var i = 0; i < types.length; i++) {
                    var t = types[i];
                    if (counts[t] > 0) {
                        html += '<div class="captured-row"><span class="captured-count">' + counts[t] + '</span>';
                        html += '<span class="captured-symbol">' + pieceSymbols[trophyColor + t] + '</span></div>';
                    }
                }
                cont.innerHTML = html;
            }

            render('chess-capturedBottomW', capturedPieces.b, 'b');
            render('chess-capturedBottomB', capturedPieces.w, 'w');
            render('chess-capturedTopB', capturedPieces.w, 'w');
            render('chess-capturedTopW', capturedPieces.b, 'b');

            if (wAdv > 0) {
                if (scoreElements[0]) scoreElements[0].textContent = '';
                if (scoreElements[1]) scoreElements[1].textContent = '+' + wAdv;
            } else if (wAdv < 0) {
                if (scoreElements[0]) scoreElements[0].textContent = '+' + (-wAdv);
                if (scoreElements[1]) scoreElements[1].textContent = '';
            } else {
                if (scoreElements[0]) scoreElements[0].textContent = '';
                if (scoreElements[1]) scoreElements[1].textContent = '';
            }
        }

        function isInsufficientMaterial() {
            var pieces = {w: [], b: []};
            var bishops = {w: [], b: []};
            
            for (var r = 0; r < 8; r++) {
                for (var c = 0; c < 8; c++) {
                    var p = board[r][c];
                    if (p) {
                        pieces[p[0]].push(p[1]);
                        if (p[1] === 'B') {
                            bishops[p[0]].push((r + c) % 2);
                        }
                    }
                }
            }
            
            if (pieces.w.length === 1 && pieces.b.length === 1) return true;
            
            if ((pieces.w.length === 2 && pieces.w.indexOf('N') !== -1 && pieces.b.length === 1) ||
                (pieces.b.length === 2 && pieces.b.indexOf('N') !== -1 && pieces.w.length === 1)) return true;
            
            if ((pieces.w.length === 2 && pieces.w.indexOf('B') !== -1 && pieces.b.length === 1) ||
                (pieces.b.length === 2 && pieces.b.indexOf('B') !== -1 && pieces.w.length === 1)) return true;
            
            if (pieces.w.length === 2 && pieces.b.length === 2 && 
                pieces.w.indexOf('B') !== -1 && pieces.b.indexOf('B') !== -1) {
                if (bishops.w.length === 1 && bishops.b.length === 1 && 
                    bishops.w[0] === bishops.b[0]) return true;
            }
            
            return false;
        }

        function isThreefoldRepetition() {
            if (historyIndex < 8) return false;
            var currHash = gameHistory[historyIndex].hash;
            var reps = 0;
            for (var i = 0; i <= historyIndex; i++) {
                if (gameHistory[i].hash === currHash) reps++;
            }
            return reps >= 3;
        }

        function updateStatus() {
            var statusTop = '';
            var statusBottom = '';
            isGameOver = false;
            
            if (isInsufficientMaterial()) {
                statusTop = statusBottom = 'Draw! (Insufficient Material)';
                isGameOver = true;
            } else if (halfMoveClock >= 100) {
                statusTop = statusBottom = 'Draw! (50-move Rule)';
                isGameOver = true;
            } else if (isThreefoldRepetition()) {
                statusTop = statusBottom = 'Draw! (Threefold Repetition)';
                isGameOver = true;
            } else {
                var inCheck = isKingInCheck(currentTurn);
                var canMove = hasLegalMoves(currentTurn);
                
                if (!canMove) {
                    isGameOver = true;
                    if (inCheck) {
                        var winner = (currentTurn === 'w' ? 'Black' : 'White');
                        statusTop = statusBottom = 'Checkmate! ' + winner + ' wins';
                    } else {
                        statusTop = statusBottom = 'Stalemate!';
                    }
                } else {
                    var checkSuffix = inCheck ? ' (Check!)' : '';
                    
                    if (currentTurn === 'w') {
                        statusBottom = 'Your move' + checkSuffix;
                        statusTop = 'White to move' + checkSuffix;
                    } else {
                        statusTop = 'Your move' + checkSuffix;
                        statusBottom = 'Black to move' + checkSuffix;
                    }
                }
            }
            
            if (statusElements[0]) statusElements[0].textContent = statusTop;
            if (statusElements[1]) statusElements[1].textContent = statusBottom;

            if (isGameOver && !statsSent && gameStartTime) {
                var gameEndTime = Date.now();
                var durationSeconds = Math.round((gameEndTime - gameStartTime) / 1000);
                gtag('event', 'game_finish', {
                    'duration': durationSeconds,
                    'result': statusTop,
                    'moves': gameHistory.length
                });
                statsSent = true;
            }
        }

        function hasLegalMoves(color) {
            for (var r = 0; r < 8; r++) {
                for (var c = 0; c < 8; c++) {
                    var p = board[r][c];
                    if (p && p[0] === color && getPossibleMoves(r, c).length > 0) return true;
                }
            }
            return false;
        }

        function isKingInCheck(color) {
            var kPos = findKing(board, color);
            return kPos && isSquareAttacked(board, kPos.row, kPos.col, color === 'w' ? 'b' : 'w');
        }

        function updateButtons() {
            updateHistoryButtons(['chess-backBtn', 'chess-backBtnBottom'], ['chess-forwardBtn', 'chess-forwardBtnBottom'], historyIndex, gameHistory.length, { isGameOver: isGameOver });
        }
        bindHistoryBack(['chess-backBtn', 'chess-backBtnBottom'], function() { if (historyIndex > 0) restoreState(historyIndex - 1); });
        bindHistoryForward(['chess-forwardBtn', 'chess-forwardBtnBottom'], function() {
            if (this.classList.contains('btn-new')) startNewGame();
            else if (historyIndex < gameHistory.length - 1) restoreState(historyIndex + 1);
        });

        function showPromotionModal() {
            if (!promotionModal) return;
            promotionModal.style.display = 'flex';
            var content = promotionModal.querySelector('.promotion-content');
            if (content) content.style.transform = currentTurn === 'b' ? 'rotate(180deg)' : 'none';
            
            var opts = promotionModal.querySelectorAll('.promo-option');
            for (var i = 0; i < opts.length; i++) {
                opts[i].innerHTML = pieceSymbols[currentTurn + opts[i].dataset.type];
            }
        }

        function hidePromotionModal() {
            if (promotionModal) promotionModal.style.display = 'none';
            pendingPromotion = null;
            clearSelection();
        }

        bindOptions('.promo-option', function() {
            if (pendingPromotion) {
                makeMove(pendingPromotion.from.row, pendingPromotion.from.col, pendingPromotion.to.row, pendingPromotion.to.col, this.dataset.type);
                hidePromotionModal();
            }
        });
        if (promotionModal) {
            var handleModalClose = function(e) {
                if (e.target === promotionModal) hidePromotionModal();
            };
            
            promotionModal.addEventListener('touchstart', function(e) {
                if (e.target === promotionModal) {
                    e.preventDefault();
                    handleModalClose(e);
                }
            }, {passive: false});
            
            promotionModal.onclick = handleModalClose;
        }

        function startGame() {
            initBackToWelcome('chess-welcomeModal', 'chess-welcomeFooter');
            runWelcomeFlow({
                modalId: 'chess-welcomeModal',
                footerId: 'chess-welcomeFooter',
                hasSave: function() { var data = loadJSON('chessGameSave'); return data && data.gameHistory && data.gameHistory.length > 1; },
                continueBtnId: 'chess-continueGameBtn',
                onContinue: function() {
                    pushStatePlaying();
                    hideWelcome('chess-welcomeModal', 'chess-welcomeFooter');
                    initBoard();
                    if (loadGame()) { hasAutoSaved = true; refreshEink(); gameStartTime = Date.now(); statsSent = false; }
                    else startNewGame();
                },
                newButtons: [{ id: 'chess-newGameBtn', fn: function() { pushStatePlaying(); hideWelcome('chess-welcomeModal', 'chess-welcomeFooter'); startNewGame(); hasAutoSaved = true; } }],
                infoModal: { modalId: 'chess-gameInfoModal', openBtnId: 'chess-gameInfoBtn', closeBtnId: 'chess-gameInfoClose' }
            });
        }

        initDoubleTapFullscreen('.board-container');
        window.ChessStartGame = startGame;
var gameMode = loadJSON('checkersGameMode') || 'english';
        var BOARD_SIZE = gameMode === 'international' ? 10 : (gameMode === 'canadian' ? 12 : 8);
        var PIECE_ROWS = gameMode === 'international' ? 4 : (gameMode === 'canadian' ? 5 : 3);

        function isDark(row, col) {
            return (row + col) % 2 === 1;
        }

        function isFlyingRules() {
            return gameMode === 'international' || gameMode === 'pool' || gameMode === 'brazilian' || gameMode === 'canadian';
        }

        function setGameMode(mode) {
            gameMode = mode;
            BOARD_SIZE = gameMode === 'international' ? 10 : (gameMode === 'canadian' ? 12 : 8);
            PIECE_ROWS = gameMode === 'international' ? 4 : (gameMode === 'canadian' ? 5 : 3);
            saveJSON('checkersGameMode', gameMode);
        }

        function startNewGame() {
            setGameMode(gameMode);
            board = [];
            var pieceStart = BOARD_SIZE - PIECE_ROWS;
            for (var r = 0; r < BOARD_SIZE; r++) {
                board[r] = [];
                for (var c = 0; c < BOARD_SIZE; c++) {
                    if (!isDark(r, c)) {
                        board[r][c] = '';
                        continue;
                    }
                    if (r >= pieceStart) board[r][c] = 'wm';
                    else if (r < PIECE_ROWS) board[r][c] = 'bm';
                    else board[r][c] = '';
                }
            }
            currentTurn = (gameMode === 'english' || gameMode === 'pool') ? 'b' : 'w';
            gameHistory = [];
            historyIndex = -1;
            capturedPieces = {w: [], b: []};
            lastMove = null;
            isGameOver = false;
            statsSent = false;
            gameStartTime = Date.now();

            clearSavedGame();
            initBoard();
            saveState();
            renderBoard();
            refreshEink();
            
            if (typeof gtag === 'function') gtag('event', 'game_start', { 'method': 'manual' });
        }

        var pieceSymbols = {};
        (function initPieceSymbols() {
            var manSvg = '<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="42" fill="#454242" stroke="#fff" stroke-width="2"/></svg>';
            var kingSvg = '<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="42" fill="#454242" stroke="#fff" stroke-width="2"/><circle cx="50" cy="50" r="24" fill="none" stroke="#fff" stroke-width="2"/></svg>';
            var types = [
                { id: 'm', svg: manSvg },
                { id: 'k', svg: kingSvg }
            ];
            for (var i = 0; i < types.length; i++) {
                var t = types[i];
                var wSvg = t.svg.replace(/fill="#454242"/g, 'fill="' + PIECE_WHITE_FILL + '"').replace(/stroke="#fff"/g, 'stroke="' + PIECE_WHITE_STROKE + '"');
                var bSvg = t.svg.replace(/fill="#454242"/g, 'fill="' + PIECE_BLACK_FILL + '"').replace(/stroke="#fff"/g, 'stroke="' + PIECE_BLACK_STROKE + '"');
                pieceSymbols['w' + t.id] = wSvg;
                pieceSymbols['b' + t.id] = bSvg;
            }
        })();

        var board;
        var currentTurn = 'w';
        var selectedSquare = null;
        var gameHistory = [];
        var historyIndex = -1;
        var capturedPieces = {w: [], b: []};
        var lastMove = null;
        var isGameOver = false;
        var hasAutoSaved = false;

        var boardElement = document.getElementById('checkers-board');
        var statusElements = [document.getElementById('checkers-status'), document.getElementById('checkers-statusBottom')];
        var scoreElements = [document.getElementById('checkers-scoreTop'), document.getElementById('checkers-scoreBottom')];
        var squareElements = [];

        function getSaveKey() {
            return 'checkersGameSave_' + gameMode;
        }

        function saveGame() {
            var gameData = {
                gameMode: gameMode,
                board: board,
                currentTurn: currentTurn,
                capturedPieces: capturedPieces,
                lastMove: lastMove,
                gameHistory: gameHistory,
                historyIndex: historyIndex,
                isGameOver: isGameOver,
                timestamp: new Date().toISOString()
            };
            saveJSON(getSaveKey(), gameData);
            saveJSON('checkersLastMode', gameMode);
        }

        function loadGame() {
            var data = loadJSON(getSaveKey());
            if (!data) return false;
            if (data.gameMode) setGameMode(data.gameMode);
            board = data.board;
            currentTurn = data.currentTurn;
            capturedPieces = data.capturedPieces;
            lastMove = data.lastMove;
            gameHistory = data.gameHistory;
            historyIndex = data.historyIndex;
            isGameOver = data.isGameOver;
            renderBoard();
            return true;
        }

        function clearSavedGame() {
            clearSaved(getSaveKey());
        }

        function getBoardHash(b, turn) {
            var s = "";
            for (var i = 0; i < BOARD_SIZE; i++) s += b[i].join(",") + "/";
            s += "|" + turn;
            return s;
        }

        function initBoard() {
            setGameMode(gameMode);
            boardElement.innerHTML = '';
            squareElements = [];
            boardElement.classList.remove('size-8', 'size-10', 'size-12');
            boardElement.classList.add('size-' + BOARD_SIZE);
            var pct = 100 / BOARD_SIZE;

            for (var row = 0; row < BOARD_SIZE; row++) {
                for (var col = 0; col < BOARD_SIZE; col++) {
                    var square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.style.position = 'absolute';
                    square.style.boxSizing = 'border-box';
                    square.style.width = pct + '%';
                    square.style.height = pct + '%';
                    square.style.top = (row * pct) + '%';
                    square.style.left = (col * pct) + '%';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    bindCell(square, handleSquareClick);

                    var pieceContainer = document.createElement('div');
                    pieceContainer.className = 'piece';
                    square.appendChild(pieceContainer);

                    boardElement.appendChild(square);
                    squareElements.push(square);
                }
            }
        }

        function renderBoard() {
            var sizeClass = 'size-' + BOARD_SIZE;
            boardElement.className = 'board ' + sizeClass;

            for (var row = 0; row < BOARD_SIZE; row++) {
                for (var col = 0; col < BOARD_SIZE; col++) {
                    var idx = row * BOARD_SIZE + col;
                    var sqEl = squareElements[idx];
                    var pieceCont = sqEl.querySelector('.piece');
                    var piece = board[row][col];
                    
                    sqEl.classList.remove('selected', 'possible-move', 'possible-capture', 'last-move');

                    if (lastMove) {
                        if ((lastMove.from.row === row && lastMove.from.col === col) || 
                            (lastMove.to.row === row && lastMove.to.col === col)) {
                            sqEl.classList.add('last-move');
                        }
                    }

                    var newContent = piece ? pieceSymbols[piece] : '';
                    if (pieceCont.getAttribute('data-piece') !== (piece || 'empty')) {
                        pieceCont.innerHTML = newContent;
                        pieceCont.setAttribute('data-piece', piece || 'empty');
                    }
                }
            }

            updateCapturedPieces();
            updateStatus();
            updateButtons();
        }

        function handleSquareClick(e) {
            if (isGameOver) return;

            var row = +e.currentTarget.dataset.row;
            var col = +e.currentTarget.dataset.col;

            if (selectedSquare) {
                var moves = getPossibleMoves(selectedSquare.row, selectedSquare.col);
                var valid = false;
                var moveObj = null;
                for (var i = 0; i < moves.length; i++) {
                    if (moves[i].row === row && moves[i].col === col) {
                        valid = true;
                        moveObj = moves[i];
                        break;
                    }
                }
                
                if (valid) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col, moveObj.captures || []);
                    clearSelection();
                } else if (board[row][col] && board[row][col][0] === currentTurn) {
                    selectSquare(row, col);
                } else {
                    clearSelection();
                }
            } else {
                if (board[row][col] && board[row][col][0] === currentTurn) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            selectedSquare = {row: row, col: col};
            renderBoard();
            
            squareElements[row * BOARD_SIZE + col].classList.add('selected');

            var moves = getPossibleMoves(row, col);
            for (var i = 0; i < moves.length; i++) {
                var m = moves[i];
                var sq = squareElements[m.row * BOARD_SIZE + m.col];
                sq.classList.add(m.captures && m.captures.length ? 'possible-capture' : 'possible-move');
            }
        }

        function clearSelection() {
            selectedSquare = null;
            renderBoard();
        }

        var DIAG = [[-1,-1],[-1,1],[1,-1],[1,1]];

        function getCaptureSequences(b, row, col, piece, fromCaptures) {
            fromCaptures = fromCaptures || [];
            var color = piece[0];
            var isKing = piece[1] === 'k';
            var fwd = color === 'w' ? -1 : 1;
            var manDirs = isFlyingRules() ? DIAG : [[fwd, -1], [fwd, 1]];
            var dirs = isKing ? DIAG : manDirs;
            var kingFlies = isFlyingRules() && isKing;
            var sequences = [];
            var N = b.length;

            for (var d = 0; d < dirs.length; d++) {
                var dr = dirs[d][0], dc = dirs[d][1];
                var step = 1;
                while (true) {
                    var jr = row + dr * step;
                    var jc = col + dc * step;
                    if (jr < 0 || jr >= N || jc < 0 || jc >= N || !isDark(jr, jc)) break;
                    var mid = b[jr][jc];
                    if (!mid) {
                        if (!kingFlies) break;
                        step++;
                        continue;
                    }
                    if (mid[0] === color) break;
                    var landR = jr + dr;
                    var landC = jc + dc;
                    if (landR < 0 || landR >= N || landC < 0 || landC >= N || !isDark(landR, landC)) break;
                    if (b[landR][landC]) break;
                    var already = false;
                    for (var z = 0; z < fromCaptures.length; z++) {
                        if (fromCaptures[z].row === jr && fromCaptures[z].col === jc) { already = true; break; }
                    }
                    if (already) {
                        if (!kingFlies) break;
                        step++;
                        continue;
                    }
                    var newCaptures = fromCaptures.slice();
                    newCaptures.push({row: jr, col: jc, piece: mid});
                    b[jr][jc] = '';
                    var sub = getCaptureSequences(b, landR, landC, piece, newCaptures);
                    b[jr][jc] = mid;
                    if (sub.length) {
                        for (var s = 0; s < sub.length; s++) sequences.push(sub[s]);
                    } else {
                        sequences.push({row: landR, col: landC, captures: newCaptures});
                    }
                    if (!kingFlies) break;
                    step++;
                }
            }
            return sequences;
        }

        function anyCaptureForColor(b, color) {
            for (var r = 0; r < BOARD_SIZE; r++) {
                for (var c = 0; c < BOARD_SIZE; c++) {
                    if (!isDark(r, c)) continue;
                    var p = b[r][c];
                    if (p && p[0] === color && getCaptureSequences(b, r, c, p).length > 0) return true;
                }
            }
            return false;
        }

        function getMaxCaptureCount(color) {
            var maxCount = 0;
            for (var r = 0; r < BOARD_SIZE; r++) {
                for (var c = 0; c < BOARD_SIZE; c++) {
                    if (!isDark(r, c)) continue;
                    var p = board[r][c];
                    if (!p || p[0] !== color) continue;
                    var seqs = getCaptureSequences(board, r, c, p);
                    for (var i = 0; i < seqs.length; i++) {
                        var cnt = seqs[i].captures ? seqs[i].captures.length : 0;
                        if (cnt > maxCount) maxCount = cnt;
                    }
                }
            }
            return maxCount;
        }

        function getSimpleMoves(b, row, col, piece) {
            var color = piece[0];
            var isKing = piece[1] === 'k';
            var moves = [];
            var fwd = color === 'w' ? -1 : 1;
            var dirs = isKing ? DIAG : [[fwd, -1], [fwd, 1]];
            var maxStep = (isFlyingRules() && isKing) ? BOARD_SIZE - 1 : 1;
            var N = b.length;

            for (var d = 0; d < dirs.length; d++) {
                var dr = dirs[d][0], dc = dirs[d][1];
                for (var step = 1; step <= maxStep; step++) {
                    var nr = row + dr * step;
                    var nc = col + dc * step;
                    if (nr < 0 || nr >= N || nc < 0 || nc >= N || !isDark(nr, nc)) break;
                    if (b[nr][nc]) break;
                    moves.push({row: nr, col: nc, captures: []});
                }
            }
            return moves;
        }

        function getPossibleMoves(row, col) {
            var piece = board[row][col];
            if (!piece || piece[0] !== currentTurn) return [];

            var captures = getCaptureSequences(board, row, col, piece);
            if (captures.length) {
                if (isFlyingRules()) {
                    var maxCount = getMaxCaptureCount(currentTurn);
                    var out = [];
                    for (var i = 0; i < captures.length; i++) {
                        var cnt = captures[i].captures ? captures[i].captures.length : 0;
                        if (cnt === maxCount) out.push(captures[i]);
                    }
                    return out;
                }
                return captures;
            }
            if (anyCaptureForColor(board, currentTurn)) return [];

            return getSimpleMoves(board, row, col, piece);
        }

        function makeMove(fr, fc, tr, tc, capturesList) {
            var piece = board[fr][fc];
            capturesList = capturesList || [];

            for (var i = 0; i < capturesList.length; i++) {
                var cap = capturesList[i];
                var cp = board[cap.row][cap.col];
                if (cp) {
                    capturedPieces[cp[0]].push(cp);
                    board[cap.row][cap.col] = '';
                }
            }
            
            board[tr][tc] = piece;
            board[fr][fc] = '';

            if (piece[1] === 'm' && (piece[0] === 'w' && tr === 0 || piece[0] === 'b' && tr === BOARD_SIZE - 1)) {
                board[tr][tc] = piece[0] + 'k';
            }

            lastMove = {from: {row: fr, col: fc}, to: {row: tr, col: tc}};
            currentTurn = currentTurn === 'w' ? 'b' : 'w';
            
            saveState();
            renderBoard();
        }

        function cloneBoard(src) {
            var dst = [];
            for (var i = 0; i < BOARD_SIZE; i++) dst[i] = src[i].slice();
            return dst;
        }

        function saveState() {
            gameHistory = gameHistory.slice(0, historyIndex + 1);
            var stateHash = getBoardHash(board, currentTurn);
            
            gameHistory.push({
                board: cloneBoard(board),
                currentTurn: currentTurn,
                capturedPieces: {w: capturedPieces.w.slice(), b: capturedPieces.b.slice()},
                lastMove: lastMove ? JSON.parse(JSON.stringify(lastMove)) : null,
                hash: stateHash
            });
            historyIndex++;
            if (hasAutoSaved) saveGame();
        }

        function restoreState(idx) {
            if (idx < 0 || idx >= gameHistory.length) return;
            
            var s = gameHistory[idx];
            board = cloneBoard(s.board);
            currentTurn = s.currentTurn;
            capturedPieces = {w: s.capturedPieces.w.slice(), b: s.capturedPieces.b.slice()};
            lastMove = s.lastMove ? {from: {row: s.lastMove.from.row, col: s.lastMove.from.col}, to: {row: s.lastMove.to.row, col: s.lastMove.to.col}} : null;
            historyIndex = idx;
            isGameOver = false;
            clearSelection();
        }

        function updateCapturedPieces() {
            var wCount = 0, bCount = 0;
            for (var r = 0; r < BOARD_SIZE; r++) {
                for (var c = 0; c < BOARD_SIZE; c++) {
                    var p = board[r][c];
                    if (p) { if (p[0] === 'w') wCount++; else bCount++; }
                }
            }
            var wCap = capturedPieces.w.length;
            var bCap = capturedPieces.b.length;
            var wAdv = bCap - wCap;
            if (wAdv > 0) {
                if (scoreElements[0]) scoreElements[0].textContent = '';
                if (scoreElements[1]) scoreElements[1].textContent = '+' + wAdv;
            } else if (wAdv < 0) {
                if (scoreElements[0]) scoreElements[0].textContent = '+' + (-wAdv);
                if (scoreElements[1]) scoreElements[1].textContent = '';
            } else {
                if (scoreElements[0]) scoreElements[0].textContent = '';
                if (scoreElements[1]) scoreElements[1].textContent = '';
            }

            function render(contId, pieces, trophyColor) {
                var cont = document.getElementById(contId);
                if (!cont) return;
                var men = 0, kings = 0;
                for (var i = 0; i < pieces.length; i++) {
                    if (pieces[i][0] === trophyColor) {
                        if (pieces[i][1] === 'm') men++; else kings++;
                    }
                }
                var html = '';
                if (men > 0) html += '<div class="captured-row"><span class="captured-count">' + men + '</span><span class="captured-symbol">' + pieceSymbols[trophyColor + 'm'] + '</span></div>';
                if (kings > 0) html += '<div class="captured-row"><span class="captured-count">' + kings + '</span><span class="captured-symbol">' + pieceSymbols[trophyColor + 'k'] + '</span></div>';
                cont.innerHTML = html;
            }

            render('checkers-capturedBottomW', capturedPieces.b, 'b');
            render('checkers-capturedBottomB', capturedPieces.w, 'w');
            render('checkers-capturedTopB', capturedPieces.w, 'w');
            render('checkers-capturedTopW', capturedPieces.b, 'b');
        }

        function updateStatus() {
            var statusTop = '';
            var statusBottom = '';
            isGameOver = false;
            
            var wHasMove = hasLegalMoves('w');
            var bHasMove = hasLegalMoves('b');
            var wCount = 0, bCount = 0;
            for (var r = 0; r < BOARD_SIZE; r++) {
                for (var c = 0; c < BOARD_SIZE; c++) {
                    var p = board[r][c];
                    if (p) { if (p[0] === 'w') wCount++; else bCount++; }
                }
            }

            if (wCount === 0) {
                statusTop = statusBottom = 'Black wins!';
                isGameOver = true;
            } else if (bCount === 0) {
                statusTop = statusBottom = 'White wins!';
                isGameOver = true;
            } else if (!wHasMove && currentTurn === 'w') {
                statusTop = statusBottom = 'Black wins! (No moves)';
                isGameOver = true;
            } else if (!bHasMove && currentTurn === 'b') {
                statusTop = statusBottom = 'White wins! (No moves)';
                isGameOver = true;
            } else {
                if (currentTurn === 'w') {
                    statusBottom = 'Your move';
                    statusTop = 'White to move';
                } else {
                    statusTop = 'Your move';
                    statusBottom = 'Black to move';
                }
            }
            
            if (statusElements[0]) statusElements[0].textContent = statusTop;
            if (statusElements[1]) statusElements[1].textContent = statusBottom;

            if (isGameOver && !statsSent && gameStartTime) {
                var gameEndTime = Date.now();
                var durationSeconds = Math.round((gameEndTime - gameStartTime) / 1000);
                if (typeof gtag === 'function') gtag('event', 'game_finish', { 'duration': durationSeconds, 'result': statusTop, 'moves': gameHistory.length });
                statsSent = true;
            }
        }

        function hasLegalMoves(color) {
            for (var r = 0; r < BOARD_SIZE; r++) {
                for (var c = 0; c < BOARD_SIZE; c++) {
                    if (!isDark(r, c)) continue;
                    var p = board[r][c];
                    if (p && p[0] === color && getPossibleMoves(r, c).length > 0) return true;
                }
            }
            return false;
        }

        function updateButtons() {
            updateHistoryButtons(['checkers-backBtn', 'checkers-backBtnBottom'], ['checkers-forwardBtn', 'checkers-forwardBtnBottom'], historyIndex, gameHistory.length, { isGameOver: isGameOver });
        }
        bindHistoryBack(['checkers-backBtn', 'checkers-backBtnBottom'], function() { if (historyIndex > 0) restoreState(historyIndex - 1); });
        bindHistoryForward(['checkers-forwardBtn', 'checkers-forwardBtnBottom'], function() {
            if (this.classList.contains('btn-new')) startNewGame();
            else if (historyIndex < gameHistory.length - 1) restoreState(historyIndex + 1);
        });

        function hasSaveForMode(mode) {
            var data = loadJSON('checkersGameSave_' + mode);
            return data && data.gameHistory && data.gameHistory.length > 1;
        }

        function hasAnySave() {
            return hasSaveForMode('english') || hasSaveForMode('international') || hasSaveForMode('pool') || hasSaveForMode('brazilian') || hasSaveForMode('canadian');
        }

        function getFirstAvailableSaveMode() {
            if (hasSaveForMode('english')) return 'english';
            if (hasSaveForMode('international')) return 'international';
            if (hasSaveForMode('pool')) return 'pool';
            if (hasSaveForMode('brazilian')) return 'brazilian';
            if (hasSaveForMode('canadian')) return 'canadian';
            return 'english';
        }

        function startGame() {
            initBackToWelcome('checkers-welcomeModal', 'checkers-welcomeFooter');
            runWelcomeFlow({
                modalId: 'checkers-welcomeModal',
                footerId: 'checkers-welcomeFooter',
                hasSave: hasAnySave,
                continueBtnId: 'checkers-continueGameBtn',
                onContinue: function() {
                    pushStatePlaying();
                    hideWelcome('checkers-welcomeModal', 'checkers-welcomeFooter');
                    var lastMode = loadJSON('checkersLastMode');
                    if (!lastMode || !hasSaveForMode(lastMode)) lastMode = getFirstAvailableSaveMode();
                    setGameMode(lastMode);
                    initBoard();
                    if (loadGame()) { hasAutoSaved = true; refreshEink(); gameStartTime = Date.now(); statsSent = false; }
                    else { startNewGame(); hasAutoSaved = true; }
                },
                newButtons: [
                    { id: 'checkers-modeEnglishBtn', fn: function() { pushStatePlaying(); hideWelcome('checkers-welcomeModal', 'checkers-welcomeFooter'); setGameMode('english'); startNewGame(); hasAutoSaved = true; } },
                    { id: 'checkers-modeInternationalBtn', fn: function() { pushStatePlaying(); hideWelcome('checkers-welcomeModal', 'checkers-welcomeFooter'); setGameMode('international'); startNewGame(); hasAutoSaved = true; } },
                    { id: 'checkers-modePoolBtn', fn: function() { pushStatePlaying(); hideWelcome('checkers-welcomeModal', 'checkers-welcomeFooter'); setGameMode('pool'); startNewGame(); hasAutoSaved = true; } },
                    { id: 'checkers-modeBrazilianBtn', fn: function() { pushStatePlaying(); hideWelcome('checkers-welcomeModal', 'checkers-welcomeFooter'); setGameMode('brazilian'); startNewGame(); hasAutoSaved = true; } },
                    { id: 'checkers-modeCanadianBtn', fn: function() { pushStatePlaying(); hideWelcome('checkers-welcomeModal', 'checkers-welcomeFooter'); setGameMode('canadian'); startNewGame(); hasAutoSaved = true; } }
                ],
                infoModal: { modalId: 'checkers-variantsInfoModal', openBtnId: 'checkers-variantsInfoBtn', closeBtnId: 'checkers-variantsInfoClose' }
            });
        }

        initDoubleTapFullscreen('.board-container');
        window.CheckersStartGame = startGame;
var DIRS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        var pieceSymbols = {};
        (function() {
            var discSvg = '<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="44" fill="' + PIECE_BLACK_FILL + '" stroke="' + PIECE_BLACK_STROKE + '" stroke-width="3"/></svg>';
            pieceSymbols['b'] = discSvg;
            pieceSymbols['w'] = '<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="44" fill="' + PIECE_WHITE_FILL + '" stroke="' + PIECE_WHITE_STROKE + '" stroke-width="3"/></svg>';
        })();
        var board;
        var currentTurn = 'b';
        var gameHistory = [];
        var historyIndex = -1;
        var lastMove = null;
        var isGameOver = false;
        var hasAutoSaved = false;
        var lastTurnWasPass = false;
        var boardElement = document.getElementById('reversi-board');
        var statusElements = [document.getElementById('reversi-status'), document.getElementById('reversi-statusBottom')];
        var scoreElements = [document.getElementById('reversi-scoreTop'), document.getElementById('reversi-scoreBottom')];
        var squareElements = [];
        function getFlips(b, r, c, color) {
            var flips = [];
            var opp = color === 'b' ? 'w' : 'b';
            for (var d = 0; d < DIRS.length; d++) {
                var dr = DIRS[d][0], dc = DIRS[d][1];
                var list = [];
                var nr = r + dr, nc = c + dc;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && b[nr][nc] === opp) {
                    list.push({row: nr, col: nc});
                    nr += dr;
                    nc += dc;
                }
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && b[nr][nc] === color && list.length > 0) {
                    for (var i = 0; i < list.length; i++) flips.push(list[i]);
                }
            }
            return flips;
        }
        function getLegalMoves(b, color) {
            var moves = [];
            for (var r = 0; r < 8; r++) {
                for (var c = 0; c < 8; c++) {
                    if (b[r][c] !== '') continue;
                    if (getFlips(b, r, c, color).length > 0) moves.push({row: r, col: c});
                }
            }
            return moves;
        }
        function startNewGame() {
            board = [
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','w','b','','',''],
                ['','','','b','w','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','','']
            ];
            currentTurn = 'b';
            gameHistory = [];
            historyIndex = -1;
            lastMove = null;
            isGameOver = false;
            lastTurnWasPass = false;
            clearSavedGame();
            initBoard();
            applyPassIfNeeded();
            saveState();
            renderBoard();
            refreshEink();
        }
        function initBoard() {
            boardElement.innerHTML = '';
            squareElements = [];
            for (var row = 0; row < 8; row++) {
                for (var col = 0; col < 8; col++) {
                    var square = document.createElement('div');
                    square.className = 'square';
                    square.classList.add('rank' + (8 - row));
                    square.classList.add('file' + (col + 1));
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        handleSquareClick.call(this, e);
                    }, {passive: false});
                    square.onclick = handleSquareClick;
                    var pieceContainer = document.createElement('div');
                    pieceContainer.className = 'piece';
                    square.appendChild(pieceContainer);
                    boardElement.appendChild(square);
                    squareElements.push(square);
                }
            }
        }
        function applyPassIfNeeded() {
            if (isGameOver) return;
            var moves = getLegalMoves(board, currentTurn);
            if (moves.length > 0) return;
            var opp = currentTurn === 'b' ? 'w' : 'b';
            if (getLegalMoves(board, opp).length > 0) {
                lastTurnWasPass = true;
                currentTurn = opp;
                applyPassIfNeeded();
            } else {
                lastTurnWasPass = false;
                isGameOver = true;
            }
        }
        function renderBoard() {
            boardElement.className = 'board ' + (currentTurn === 'b' ? 'black-turn' : 'white-turn');
            var legalMoves = isGameOver ? [] : getLegalMoves(board, currentTurn);
            for (var row = 0; row < 8; row++) {
                for (var col = 0; col < 8; col++) {
                    var idx = row * 8 + col;
                    var sqEl = squareElements[idx];
                    var pieceCont = sqEl.querySelector('.piece');
                    var piece = board[row][col];
                    sqEl.classList.remove('last-move', 'possible-move');
                    if (lastMove && lastMove.row === row && lastMove.col === col) {
                        sqEl.classList.add('last-move');
                    }
                    var isLegal = false;
                    for (var i = 0; i < legalMoves.length; i++) {
                        if (legalMoves[i].row === row && legalMoves[i].col === col) {
                            isLegal = true;
                            break;
                        }
                    }
                    if (isLegal) sqEl.classList.add('possible-move');
                    var newContent = piece ? pieceSymbols[piece] : '';
                    if (pieceCont.getAttribute('data-piece') !== (piece || 'empty')) {
                        pieceCont.innerHTML = newContent;
                        pieceCont.setAttribute('data-piece', piece || 'empty');
                    }
                }
            }
            updateStatus();
            updateButtons();
        }
        function handleSquareClick(e) {
            if (isGameOver) return;
            var row = +e.currentTarget.dataset.row;
            var col = +e.currentTarget.dataset.col;
            var legalMoves = getLegalMoves(board, currentTurn);
            var valid = false;
            for (var i = 0; i < legalMoves.length; i++) {
                if (legalMoves[i].row === row && legalMoves[i].col === col) {
                    valid = true;
                    break;
                }
            }
            if (!valid) return;
            var flips = getFlips(board, row, col, currentTurn);
            for (var i = 0; i < flips.length; i++) {
                board[flips[i].row][flips[i].col] = currentTurn;
            }
            board[row][col] = currentTurn;
            lastMove = {row: row, col: col};
            currentTurn = currentTurn === 'b' ? 'w' : 'b';
            lastTurnWasPass = false;
            saveState();
            applyPassIfNeeded();
            renderBoard();
        }
        function cloneBoard(src) {
            var dst = [];
            for (var i = 0; i < 8; i++) dst[i] = src[i].slice();
            return dst;
        }
        function getBoardHash(b, turn) {
            var s = '';
            for (var i = 0; i < 8; i++) s += b[i].join(',') + '/';
            return s + '|' + turn;
        }
        function saveState() {
            gameHistory = gameHistory.slice(0, historyIndex + 1);
            gameHistory.push({
                board: cloneBoard(board),
                currentTurn: currentTurn,
                lastMove: lastMove ? {row: lastMove.row, col: lastMove.col} : null,
                isGameOver: isGameOver,
                lastTurnWasPass: lastTurnWasPass,
                hash: getBoardHash(board, currentTurn)
            });
            historyIndex++;
            if (hasAutoSaved) saveGame();
        }
        function restoreState(idx) {
            if (idx < 0 || idx >= gameHistory.length) return;
            historyIndex = idx;
            var s = gameHistory[idx];
            board = cloneBoard(s.board);
            currentTurn = s.currentTurn;
            lastMove = s.lastMove ? {row: s.lastMove.row, col: s.lastMove.col} : null;
            isGameOver = s.isGameOver;
            lastTurnWasPass = s.lastTurnWasPass === true;
            renderBoard();
        }
        function updateStatus() {
            var bCount = 0, wCount = 0;
            for (var r = 0; r < 8; r++) {
                for (var c = 0; c < 8; c++) {
                    if (board[r][c] === 'b') bCount++;
                    else if (board[r][c] === 'w') wCount++;
                }
            }
            var statusTop = '';
            var statusBottom = '';
            if (isGameOver) {
                if (bCount > wCount) statusTop = statusBottom = 'Black wins!';
                else if (wCount > bCount) statusTop = statusBottom = 'White wins!';
                else statusTop = statusBottom = 'Draw!';
            } else {
                if (lastTurnWasPass) {
                    var passMsg = (currentTurn === 'b' ? 'White had no moves — Black' : 'Black had no moves — White') + ' to move';
                    statusTop = statusBottom = passMsg;
                } else {
                    if (currentTurn === 'b') {
                        statusTop = 'Your move';
                        statusBottom = 'Black to move';
                    } else {
                        statusTop = 'White to move';
                        statusBottom = 'Your move';
                    }
                }
            }
            if (statusElements[0]) statusElements[0].textContent = statusTop;
            if (statusElements[1]) statusElements[1].textContent = statusBottom;
            var scoreText = bCount + ' – ' + wCount;
            if (scoreElements[0]) scoreElements[0].textContent = scoreText;
            if (scoreElements[1]) scoreElements[1].textContent = scoreText;
        }
        function updateButtons() {
            updateHistoryButtons(['reversi-backBtn', 'reversi-backBtnBottom'], ['reversi-forwardBtn', 'reversi-forwardBtnBottom'], historyIndex, gameHistory.length, { isGameOver: isGameOver });
        }
        function saveGame() {
            var gameData = {
                board: board,
                currentTurn: currentTurn,
                lastMove: lastMove,
                gameHistory: gameHistory,
                historyIndex: historyIndex,
                isGameOver: isGameOver,
                timestamp: new Date().toISOString()
            };
            saveJSON('reversiGameSave', gameData);
        }
        function loadGame() {
            var data = loadJSON('reversiGameSave');
            if (!data) return false;
            board = data.board;
            currentTurn = data.currentTurn;
            lastMove = data.lastMove;
            gameHistory = data.gameHistory || [];
            historyIndex = data.historyIndex != null ? data.historyIndex : gameHistory.length - 1;
            isGameOver = data.isGameOver;
            var s = gameHistory[historyIndex];
            lastTurnWasPass = s && s.lastTurnWasPass === true;
            renderBoard();
            return true;
        }
        function clearSavedGame() {
            clearSaved('reversiGameSave');
        }
        bindHistoryBack(['reversi-backBtn', 'reversi-backBtnBottom'], function() { if (historyIndex > 0) restoreState(historyIndex - 1); });
        bindHistoryForward(['reversi-forwardBtn', 'reversi-forwardBtnBottom'], function() {
            if (this.classList.contains('btn-new')) startNewGame();
            else if (historyIndex < gameHistory.length - 1) restoreState(historyIndex + 1);
        });
        function startGame() {
            initBackToWelcome('reversi-welcomeModal', 'reversi-welcomeFooter');
            runWelcomeFlow({
                modalId: 'reversi-welcomeModal',
                footerId: 'reversi-welcomeFooter',
                hasSave: function() { return !!loadJSON('reversiGameSave'); },
                continueBtnId: 'reversi-continueGameBtn',
                onContinue: function() {
                    pushStatePlaying();
                    hideWelcome('reversi-welcomeModal', 'reversi-welcomeFooter');
                    initBoard();
                    if (loadGame()) { hasAutoSaved = true; refreshEink(); }
                    else startNewGame();
                },
                newButtons: [{ id: 'reversi-newGameBtn', fn: function() { pushStatePlaying(); hideWelcome('reversi-welcomeModal', 'reversi-welcomeFooter'); startNewGame(); hasAutoSaved = true; } }],
                infoModal: { modalId: 'reversi-gameInfoModal', openBtnId: 'reversi-gameInfoBtn', closeBtnId: 'reversi-gameInfoClose' }
            });
        }
        initDoubleTapFullscreen('.board-container');
        window.ReversiStartGame = startGame;
var VALID_ENGLISH = [
            [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0]
        ];
        var VALID_FRENCH = [
            [0,0,1,1,1,0,0], [0,1,1,1,1,1,0], [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [1,1,1,1,1,1,1], [0,1,1,1,1,1,0], [0,0,1,1,1,0,0]
        ];
        var VALID = VALID_ENGLISH;
        var boardVariant = 'english';
        var board = [];
        var selectedCell = null;
        var gameHistory = [];
        var historyIndex = -1;
        var isGameOver = false;
        var boardEl, statusBottomEl, scoreBottomEl;
        var hasAutoSaved = false;
        function initBoard() {
            for (var r = 0; r < 7; r++) {
                board[r] = [];
                for (var c = 0; c < 7; c++) {
                    board[r][c] = VALID[r][c] ? 1 : -1;
                }
            }
            board[3][3] = 0;
        }
        function getLegalMoves() {
            var moves = [];
            for (var r = 0; r < 7; r++) {
                for (var c = 0; c < 7; c++) {
                    if (board[r][c] !== 1) continue;
                    var dirs = [[-2,0], [2,0], [0,-2], [0,2]];
                    for (var d = 0; d < dirs.length; d++) {
                        var nr = r + dirs[d][0], nc = c + dirs[d][1];
                        var mr = r + dirs[d][0]/2, mc = c + dirs[d][1]/2;
                        if (nr < 0 || nr > 6 || nc < 0 || nc > 6) continue;
                        if (!VALID[nr][nc] || board[nr][nc] !== 0) continue;
                        if (!VALID[mr][mc] || board[mr][mc] !== 1) continue;
                        moves.push({ fromR: r, fromC: c, toR: nr, toC: nc, midR: mr, midC: mc });
                    }
                }
            }
            return moves;
        }
        function getMovesFrom(r, c) {
            var moves = getLegalMoves();
            var out = [];
            for (var i = 0; i < moves.length; i++) {
                if (moves[i].fromR === r && moves[i].fromC === c) out.push(moves[i]);
            }
            return out;
        }
        function applyMove(m) {
            board[m.fromR][m.fromC] = 0;
            board[m.midR][m.midC] = 0;
            board[m.toR][m.toC] = 1;
        }
        function pegCount() {
            var n = 0;
            for (var r = 0; r < 7; r++) for (var c = 0; c < 7; c++) if (board[r][c] === 1) n++;
            return n;
        }
        function checkGameOver() {
            if (getLegalMoves().length > 0) return false;
            isGameOver = true;
            return true;
        }
        function buildBoard() {
            boardEl.innerHTML = '';
            for (var r = 0; r < 7; r++) {
                for (var c = 0; c < 7; c++) {
                    var cell = document.createElement('div');
                    cell.className = 'hole';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (!VALID[r][c]) cell.classList.add('invalid');
                    var dot = document.createElement('div');
                    dot.className = 'peg-dot' + (board[r][c] !== 1 ? ' hidden' : '');
                    cell.appendChild(dot);
                    boardEl.appendChild(cell);
                }
            }
        }
        function render() {
            var cells = boardEl.querySelectorAll('.hole');
            for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                var r = parseInt(cell.dataset.row, 10), c = parseInt(cell.dataset.col, 10);
                if (!VALID[r][c]) continue;
                cell.classList.remove('selected', 'possible');
                var dot = cell.querySelector('.peg-dot');
                if (dot) {
                    if (board[r][c] === 1) dot.classList.remove('hidden');
                    else dot.classList.add('hidden');
                }
                if (selectedCell && selectedCell[0] === r && selectedCell[1] === c) cell.classList.add('selected');
            }
            if (selectedCell) {
                var moves = getMovesFrom(selectedCell[0], selectedCell[1]);
                for (var i = 0; i < moves.length; i++) {
                    var to = boardEl.querySelector('.hole[data-row="' + moves[i].toR + '"][data-col="' + moves[i].toC + '"]');
                    if (to) to.classList.add('possible');
                }
            }
            var pegs = pegCount();
            scoreBottomEl.textContent = 'Pegs: ' + pegs;
            var statusText = '';
            if (isGameOver) {
                if (pegs === 1) statusText = 'You win!';
                else statusText = 'No moves left.';
            }
            statusBottomEl.textContent = statusText;
            updateButtons();
        }
        function onCellClick(e) {
            if (isGameOver) return;
            var cell = e.target.closest('.hole');
            if (!cell || cell.classList.contains('invalid')) return;
            var r = parseInt(cell.dataset.row, 10), c = parseInt(cell.dataset.col, 10);
            if (selectedCell) {
                var moves = getMovesFrom(selectedCell[0], selectedCell[1]);
                for (var i = 0; i < moves.length; i++) {
                    if (moves[i].toR === r && moves[i].toC === c) {
                        applyMove(moves[i]);
                        selectedCell = null;
                        checkGameOver();
                        saveState();
                        render();
                        return;
                    }
                }
                selectedCell = (board[r][c] === 1) ? [r, c] : null;
            } else {
                selectedCell = (board[r][c] === 1) ? [r, c] : null;
            }
            render();
        }
        function cloneBoard() {
            var b = [];
            for (var r = 0; r < 7; r++) { b[r] = board[r].slice(); }
            return b;
        }
        function saveState() {
            gameHistory = gameHistory.slice(0, historyIndex + 1);
            gameHistory.push({ board: cloneBoard(), isGameOver: isGameOver, variant: boardVariant });
            historyIndex++;
            if (hasAutoSaved) saveGame();
        }
        function saveGame() {
            if (gameHistory.length === 0) return;
            saveJSON('pegSolitaireSave', { gameHistory: gameHistory, historyIndex: historyIndex });
        }
        function restoreState(idx) {
            if (idx < 0 || idx >= gameHistory.length) return;
            historyIndex = idx;
            var s = gameHistory[idx];
            for (var r = 0; r < 7; r++) for (var c = 0; c < 7; c++) board[r][c] = s.board[r][c];
            isGameOver = s.isGameOver;
            selectedCell = null;
            render();
        }
        function updateButtons() {
            updateHistoryButtons(['peg-backBtnBottom'], ['peg-forwardBtnBottom'], historyIndex, gameHistory.length, { isGameOver: isGameOver });
        }
        function startNewGame(variant) {
            boardVariant = variant || 'english';
            VALID = boardVariant === 'french' ? VALID_FRENCH : VALID_ENGLISH;
            initBoard();
            selectedCell = null;
            gameHistory = [];
            historyIndex = -1;
            isGameOver = false;
            clearSaved('pegSolitaireSave');
            buildBoard();
            saveState();
            render();
            refreshEink();
        }
        window.PegStartGame = function() {
            boardEl = document.getElementById('peg-board');
            statusBottomEl = document.getElementById('peg-statusBottom');
            scoreBottomEl = document.getElementById('peg-scoreBottom');
            initBoard();
            buildBoard();
            boardEl.addEventListener('click', onCellClick);
            bindButton('peg-backBtnBottom', function() { if (historyIndex > 0) { restoreState(historyIndex - 1); updateButtons(); } });
            bindButton('peg-forwardBtnBottom', function() {
                if (this.classList.contains('btn-new')) startNewGame(boardVariant);
                else if (historyIndex < gameHistory.length - 1) { restoreState(historyIndex + 1); updateButtons(); }
            });
            function loadGame() {
                var data = loadJSON('pegSolitaireSave');
                if (!data) return false;
                gameHistory = data.gameHistory || [];
                historyIndex = data.historyIndex != null ? data.historyIndex : gameHistory.length - 1;
                if (gameHistory.length > 0) {
                    var s = gameHistory[historyIndex];
                    boardVariant = s.variant || 'english';
                    VALID = boardVariant === 'french' ? VALID_FRENCH : VALID_ENGLISH;
                    for (var r = 0; r < 7; r++) for (var c = 0; c < 7; c++) board[r][c] = s.board[r][c];
                    isGameOver = s.isGameOver;
                }
                buildBoard();
                render();
                return true;
            }
            function hasSave() {
                var d = loadJSON('pegSolitaireSave');
                return d && d.gameHistory && d.gameHistory.length > 1;
            }
            initBackToWelcome('peg-welcomeModal', 'peg-welcomeFooter');
            runWelcomeFlow({
                modalId: 'peg-welcomeModal',
                footerId: 'peg-welcomeFooter',
                hasSave: hasSave,
                continueBtnId: 'peg-continueGameBtn',
                onContinue: function() {
                    pushStatePlaying();
                    hideWelcome('peg-welcomeModal', 'peg-welcomeFooter');
                    initBoard();
                    buildBoard();
                    if (loadGame()) { hasAutoSaved = true; refreshEink(); }
                    else { startNewGame('english'); hasAutoSaved = true; }
                },
                newButtons: [
                    { id: 'peg-newGameEnglishBtn', fn: function() { pushStatePlaying(); hideWelcome('peg-welcomeModal', 'peg-welcomeFooter'); startNewGame('english'); hasAutoSaved = true; } },
                    { id: 'peg-newGameFrenchBtn', fn: function() { pushStatePlaying(); hideWelcome('peg-welcomeModal', 'peg-welcomeFooter'); startNewGame('french'); hasAutoSaved = true; } }
                ],
                infoModal: { modalId: 'peg-gameInfoModal', openBtnId: 'peg-gameInfoBtn', closeBtnId: 'peg-gameInfoClose' }
            });
            initDoubleTapFullscreen('.board-container');
        };
        registerServiceWorker();
var points = [];
        var barWhite = 0, barBlack = 0, offWhite = 0, offBlack = 0;
        var currentTurn = 'w';
        var dice = [0, 0];
        var remainingMoves = [];
        var selectedPoint = null;
        var gameHistory = [];
        var historyIndex = -1;
        var isGameOver = false;
        var phase = 'roll';
        var boardWrap, statusEl, statusBottomEl, rollBtn, die1El, die2El;
        function initPoints() {
            for (var i = 1; i <= 24; i++) points[i] = { w: 0, b: 0 };
            points[24].w = 2; points[13].w = 5; points[8].w = 3; points[6].w = 5;
            points[1].b = 2; points[12].b = 5; points[17].b = 3; points[19].b = 5;
            barWhite = 0; barBlack = 0; offWhite = 0; offBlack = 0;
        }
        function whiteHome() { var n = 0; for (var i = 1; i <= 6; i++) n += points[i].w; return n; }
        function blackHome() { var n = 0; for (var i = 19; i <= 24; i++) n += points[i].b; return n; }
        function allWhiteHome() { return barWhite === 0 && (function(){ for (var i = 7; i <= 24; i++) if (points[i].w > 0) return false; return true; })(); }
        function allBlackHome() { return barBlack === 0 && (function(){ for (var i = 1; i <= 18; i++) if (points[i].b > 0) return false; return true; })(); }
        function canEnterWhite(d) { var p = 24 - d; if (p < 1) return false; return points[p].b <= 1; }
        function canEnterBlack(d) { var p = d; if (p > 24) return false; return points[p].w <= 1; }
        function canMoveWhite(from, die) { var to = from - die; if (to < 1) return allWhiteHome() && from <= die; if (points[to].b >= 2) return false; return true; }
        function canMoveBlack(from, die) { var to = from + die; if (to > 24) return allBlackHome() && from >= 25 - die; if (points[to].w >= 2) return false; return true; }
        function getLegalMoves() {
            var moves = [];
            var color = currentTurn;
            if (remainingMoves.length === 0) return moves;
            if (color === 'w') {
                if (barWhite > 0) {
                    for (var i = 0; i < remainingMoves.length; i++) {
                        var d = remainingMoves[i];
                        if (canEnterWhite(d)) moves.push({ from: 'bar', to: 24 - d, die: d, dieIndex: i });
                    }
                    return moves;
                }
                for (var p = 24; p >= 1; p--) {
                    if (points[p].w === 0) continue;
                    for (var i = 0; i < remainingMoves.length; i++) {
                        var d = remainingMoves[i];
                        if (canMoveWhite(p, d)) {
                            var to = p - d;
                            if (to < 1) to = 'off';
                            moves.push({ from: p, to: to, die: d, dieIndex: i });
                        }
                    }
                }
            } else {
                if (barBlack > 0) {
                    for (var i = 0; i < remainingMoves.length; i++) {
                        var d = remainingMoves[i];
                        if (canEnterBlack(d)) moves.push({ from: 'bar', to: d, die: d, dieIndex: i });
                    }
                    return moves;
                }
                for (var p = 1; p <= 24; p++) {
                    if (points[p].b === 0) continue;
                    for (var i = 0; i < remainingMoves.length; i++) {
                        var d = remainingMoves[i];
                        if (canMoveBlack(p, d)) {
                            var to = p + d;
                            if (to > 24) to = 'off';
                            moves.push({ from: p, to: to, die: d, dieIndex: i });
                        }
                    }
                }
            }
            return moves;
        }
        function moveMatches(from, to, die) {
            var moves = getLegalMoves();
            for (var i = 0; i < moves.length; i++) {
                var m = moves[i];
                if (m.from !== from || m.to !== to || m.die !== die) continue;
                return m;
            }
            return null;
        }
        function applyMove(m) {
            var color = currentTurn;
            if (m.from === 'bar') {
                if (color === 'w') { barWhite--; if (points[m.to].b === 1) { points[m.to].b = 0; barBlack++; } points[m.to].w++; }
                else { barBlack--; if (points[m.to].w === 1) { points[m.to].w = 0; barWhite++; } points[m.to].b++; }
            } else {
                var from = m.from;
                if (color === 'w') {
                    points[from].w--;
                    if (m.to === 'off') offWhite++;
                    else { if (points[m.to].b === 1) { points[m.to].b = 0; barBlack++; } points[m.to].w++; }
                } else {
                    points[from].b--;
                    if (m.to === 'off') offBlack++;
                    else { if (points[m.to].w === 1) { points[m.to].w = 0; barWhite++; } points[m.to].b++; }
                }
            }
            remainingMoves.splice(m.dieIndex, 1);
            if (remainingMoves.length === 0) { currentTurn = color === 'w' ? 'b' : 'w'; phase = 'roll'; }
            if (offWhite === 15 || offBlack === 15) isGameOver = true;
        }
        function rollDice() {
            dice[0] = 1 + Math.floor(Math.random() * 6);
            dice[1] = 1 + Math.floor(Math.random() * 6);
            if (dice[0] === dice[1]) remainingMoves = [dice[0], dice[0], dice[0], dice[0]];
            else remainingMoves = [dice[0], dice[1]];
            phase = 'move';
            var moves = getLegalMoves();
            if (moves.length === 0) { currentTurn = currentTurn === 'w' ? 'b' : 'w'; phase = 'roll'; }
        }
        function startNewGame() {
            initPoints();
            currentTurn = 'w';
            dice = [0, 0];
            remainingMoves = [];
            selectedPoint = null;
            gameHistory = [];
            historyIndex = -1;
            isGameOver = false;
            phase = 'roll';
            clearSaved('backgammonGameSave');
            buildBoard();
            saveState();
            render();
            refreshEink();
        }
        function buildBoard() {
            boardWrap.innerHTML = '';
            function addHalf(orders) {
                var half = document.createElement('div');
                half.className = 'board-half';
                for (var r = 0; r < orders.length; r++) {
                    var row = document.createElement('div');
                    row.className = 'board-row';
                    for (var i = 0; i < orders[r].length; i++) {
                        var pt = orders[r][i];
                        var div = document.createElement('div');
                        div.className = 'point';
                        div.dataset.point = pt;
                        div.innerHTML = '<span class="point-num">' + pt + '</span><div class="checker-stack" data-point="' + pt + '"></div>';
                        row.appendChild(div);
                    }
                    half.appendChild(row);
                }
                boardWrap.appendChild(half);
            }
            addHalf([[24, 23, 22, 21, 20, 19], [18, 17, 16, 15, 14, 13]]);
            var bar = document.createElement('div');
            bar.className = 'bar-area';
            bar.innerHTML = '<span class="bar-label">Bar</span><span id="barWhiteCount" class="bar-label">W:0</span><span id="barBlackCount" class="bar-label">B:0</span>';
            boardWrap.appendChild(bar);
            addHalf([[12, 11, 10, 9, 8, 7], [6, 5, 4, 3, 2, 1]]);
        }
        function render() {
            for (var p = 1; p <= 24; p++) {
                var stack = boardWrap.querySelector('.point[data-point="' + p + '"] .checker-stack');
                if (!stack) continue;
                stack.innerHTML = '';
                var pw = points[p].w, pb = points[p].b;
                for (var i = 0; i < pw; i++) { var c = document.createElement('div'); c.className = 'checker white'; stack.appendChild(c); }
                for (var i = 0; i < pb; i++) { var c = document.createElement('div'); c.className = 'checker black'; stack.appendChild(c); }
            }
            var bw = document.getElementById('barWhiteCount');
            var bb = document.getElementById('barBlackCount');
            if (bw) bw.textContent = 'W:' + barWhite;
            if (bb) bb.textContent = 'B:' + barBlack;
            die1El.textContent = dice[0] || '–';
            die2El.textContent = dice[1] || '–';
            rollBtn.style.display = (phase === 'roll' && !isGameOver) ? 'block' : 'none';
            var ptEls = boardWrap.querySelectorAll('.point');
            for (var i = 0; i < ptEls.length; i++) {
                var el = ptEls[i];
                el.classList.remove('selected', 'possible');
                var pt = parseInt(el.dataset.point, 10);
                if (selectedPoint === pt) el.classList.add('selected');
            }
            var moves = getLegalMoves();
            if (selectedPoint !== null && phase === 'move') {
                for (var i = 0; i < moves.length; i++) {
                    if (moves[i].from !== selectedPoint && moves[i].from !== 'bar') continue;
                    var to = moves[i].to;
                    if (to === 'off') {
                        var fromPt = moves[i].from;
                        var fromEl = boardWrap.querySelector('.point[data-point="' + fromPt + '"]');
                        if (fromEl) fromEl.classList.add('possible');
                        continue;
                    }
                    var toEl = boardWrap.querySelector('.point[data-point="' + to + '"]');
                    if (toEl) toEl.classList.add('possible');
                }
                if (currentTurn === 'w' && barWhite > 0) {
                    for (var i = 0; i < moves.length; i++) {
                        var to = moves[i].to;
                        if (to === 'off') {
                            var fromPt = moves[i].from;
                            var fromEl = boardWrap.querySelector('.point[data-point="' + fromPt + '"]');
                            if (fromEl) fromEl.classList.add('possible');
                        } else {
                            var toEl = boardWrap.querySelector('.point[data-point="' + to + '"]');
                            if (toEl) toEl.classList.add('possible');
                        }
                    }
                }
                if (currentTurn === 'b' && barBlack > 0) {
                    for (var i = 0; i < moves.length; i++) {
                        var to = moves[i].to;
                        if (to === 'off') {
                            var fromPt = moves[i].from;
                            var fromEl = boardWrap.querySelector('.point[data-point="' + fromPt + '"]');
                            if (fromEl) fromEl.classList.add('possible');
                        } else {
                            var toEl = boardWrap.querySelector('.point[data-point="' + to + '"]');
                            if (toEl) toEl.classList.add('possible');
                        }
                    }
                }
            }
            var statusTop = '';
            var statusBottom = '';
            if (isGameOver) {
                statusTop = statusBottom = offWhite === 15 ? 'White wins!' : 'Black wins!';
            } else if (phase === 'roll') {
                if (currentTurn === 'w') {
                    statusTop = 'White to roll';
                    statusBottom = 'Your move';
                } else {
                    statusTop = 'Your move';
                    statusBottom = 'Black to roll';
                }
            } else {
                if (currentTurn === 'w') {
                    statusTop = 'White to move';
                    statusBottom = 'Your move';
                } else {
                    statusTop = 'Your move';
                    statusBottom = 'Black to move';
                }
            }
            statusEl.textContent = statusTop;
            statusBottomEl.textContent = statusBottom;
            var barEl = boardWrap.querySelector('.bar-area');
            if (barEl) { barEl.classList.remove('selected'); if (selectedPoint === 'bar') barEl.classList.add('selected'); }
            updateButtons();
        }
        function onBoardClick(e) {
            if (e.target.closest('.bar-area')) {
                if (isGameOver || phase === 'roll') return;
                if ((currentTurn === 'w' && barWhite > 0) || (currentTurn === 'b' && barBlack > 0)) {
                    selectedPoint = selectedPoint === 'bar' ? null : 'bar';
                    render();
                }
                return;
            }
            onPointClick(e);
        }
        function onPointClick(e) {
            if (isGameOver) return;
            var el = e.target.closest('.point');
            if (!el) return;
            var pt = parseInt(el.dataset.point, 10);
            if (phase === 'roll') return;
            var color = currentTurn;
            var moves = getLegalMoves();
            if (selectedPoint === null) {
                if (color === 'w' && points[pt].w > 0) selectedPoint = pt;
                else if (color === 'b' && points[pt].b > 0) selectedPoint = pt;
                else if ((color === 'w' && barWhite > 0) || (color === 'b' && barBlack > 0)) selectedPoint = 'bar';
                render();
                return;
            }
            var from = selectedPoint;
            var to = pt;
            var die = null;
            var dieIdx = -1;
            for (var i = 0; i < moves.length; i++) {
                var m = moves[i];
                if (m.from !== from) continue;
                if (m.to === to) { die = m.die; dieIdx = m.dieIndex; break; }
                if (m.to === 'off' && pt === from) { die = m.die; dieIdx = m.dieIndex; to = 'off'; break; }
            }
            if (die === null && from !== 'bar') {
                var dist = color === 'w' ? from - pt : pt - from;
                for (var i = 0; i < remainingMoves.length; i++) {
                    if (remainingMoves[i] === dist) {
                        var legal = getLegalMoves();
                        for (var j = 0; j < legal.length; j++) {
                            if (legal[j].from === from && legal[j].to === pt) { die = legal[j].die; dieIdx = legal[j].dieIndex; break; }
                        }
                        if (die !== null) break;
                    }
                }
            }
            if (die === null) {
                selectedPoint = (from === pt) ? null : (color === 'w' && points[pt].w > 0) || (color === 'b' && points[pt].b > 0) ? pt : null;
                if (!selectedPoint && (color === 'w' && barWhite > 0 || color === 'b' && barBlack > 0)) selectedPoint = 'bar';
                render();
                return;
            }
            var m = moveMatches(from, to, die);
            if (!m) {
                if (color === 'w' && to >= 1 && to <= 6 && from - die < 1 && allWhiteHome()) m = moveMatches(from, 'off', die);
                if (color === 'b' && to >= 19 && to <= 24 && from + die > 24 && allBlackHome()) m = moveMatches(from, 'off', die);
            }
            if (m) {
                saveState();
                applyMove(m);
                selectedPoint = null;
                render();
                saveState();
            }
            render();
        }
        function cloneState() {
            var p = [];
            for (var i = 1; i <= 24; i++) p[i] = { w: points[i].w, b: points[i].b };
            return { points: p, barWhite: barWhite, barBlack: barBlack, offWhite: offWhite, offBlack: offBlack, currentTurn: currentTurn, dice: [dice[0], dice[1]], remainingMoves: remainingMoves.slice(), phase: phase, isGameOver: isGameOver };
        }
        function restoreState(s) {
            for (var i = 1; i <= 24; i++) { points[i].w = s.points[i].w; points[i].b = s.points[i].b; }
            barWhite = s.barWhite; barBlack = s.barBlack; offWhite = s.offWhite; offBlack = s.offBlack;
            currentTurn = s.currentTurn; dice = [s.dice[0], s.dice[1]]; remainingMoves = s.remainingMoves.slice(); phase = s.phase; isGameOver = s.isGameOver;
            selectedPoint = null;
        }
        function saveState() {
            gameHistory = gameHistory.slice(0, historyIndex + 1);
            gameHistory.push(cloneState());
            historyIndex++;
        }
        function restoreHistory(idx) {
            if (idx < 0 || idx >= gameHistory.length) return;
            historyIndex = idx;
            restoreState(gameHistory[idx]);
            render();
        }
        function updateButtons() {
            updateHistoryButtons(['backgammon-backBtn', 'backgammon-backBtnBottom'], ['backgammon-forwardBtn', 'backgammon-forwardBtnBottom'], historyIndex, gameHistory.length, { isGameOver: isGameOver });
        }
        window.BackgammonStartGame = function() {
            boardWrap = document.getElementById('backgammon-boardWrap');
            statusEl = document.getElementById('backgammon-status');
            statusBottomEl = document.getElementById('backgammon-statusBottom');
            rollBtn = document.getElementById('backgammon-rollBtn');
            die1El = document.getElementById('backgammon-die1');
            die2El = document.getElementById('backgammon-die2');
            initPoints();
            buildBoard();
            boardWrap.addEventListener('click', onBoardClick);
            bindButton('backgammon-rollBtn', function() { saveState(); rollDice(); render(); saveState(); updateButtons(); });
            bindHistoryBack(['backgammon-backBtn', 'backgammon-backBtnBottom'], function() { if (historyIndex > 0) restoreHistory(historyIndex - 1); updateButtons(); });
            bindHistoryForward(['backgammon-forwardBtn', 'backgammon-forwardBtnBottom'], function() {
                if (this.classList.contains('btn-new')) startNewGame();
                else if (historyIndex < gameHistory.length - 1) restoreHistory(historyIndex + 1);
                updateButtons();
            });
            function loadGame() {
                var data = loadJSON('backgammonGameSave');
                if (!data) return false;
                gameHistory = data.gameHistory || [];
                historyIndex = data.historyIndex != null ? data.historyIndex : gameHistory.length - 1;
                if (gameHistory.length > 0) restoreState(gameHistory[historyIndex]);
                buildBoard();
                render();
                updateButtons();
                return true;
            }
            function saveGame() {
                saveJSON('backgammonGameSave', { gameHistory: gameHistory, historyIndex: historyIndex });
            }
            initBackToWelcome('backgammon-welcomeModal', 'backgammon-welcomeFooter');
            runWelcomeFlow({
                modalId: 'backgammon-welcomeModal',
                footerId: 'backgammon-welcomeFooter',
                hasSave: function() { return !!loadJSON('backgammonGameSave'); },
                continueBtnId: 'backgammon-continueGameBtn',
                onContinue: function() {
                    pushStatePlaying();
                    hideWelcome('backgammon-welcomeModal', 'backgammon-welcomeFooter');
                    if (!loadGame()) startNewGame();
                    refreshEink();
                },
                newButtons: [{ id: 'backgammon-newGameBtn', fn: function() { pushStatePlaying(); hideWelcome('backgammon-welcomeModal', 'backgammon-welcomeFooter'); startNewGame(); } }],
                infoModal: { modalId: 'backgammon-gameInfoModal', openBtnId: 'backgammon-gameInfoBtn', closeBtnId: 'backgammon-gameInfoClose' }
            });
            initDoubleTapFullscreen('.board-container');
            setInterval(function() { if (gameHistory.length > 0 && !isGameOver) saveGame(); }, 2000);
        };
        registerServiceWorker();

window._einkOverlayId = null;
function showScreen(id) { var s = document.querySelectorAll('.game-screen'); for (var i = 0; i < s.length; i++) s[i].style.display = 'none'; document.getElementById('screen-main').style.display = (id === 'main') ? 'flex' : 'none'; if (id !== 'main') { window._einkOverlayId = id + '-eink-refresh-overlay'; var el = document.getElementById('screen-' + id); if (el) el.style.display = 'block'; var fnName = { chess: 'chessStartGame', checkers: 'checkersStartGame', reversi: 'reversiStartGame', peg: 'pegStartGame', backgammon: 'backgammonStartGame' }[id]; var initedKey = { chess: '_initedChess', checkers: '_initedCheckers', reversi: '_initedReversi', peg: '_initedPeg', backgammon: '_initedBackgammon' }[id]; if (fnName && !window[initedKey]) { window[initedKey] = true; if (typeof window[fnName] === 'function') window[fnName](); } } else { window._einkOverlayId = null; } } window.addEventListener('hashchange', function() { var id = (location.hash || '#main').slice(1) || 'main'; showScreen(id); }); if (location.hash && location.hash !== '#main') showScreen(location.hash.slice(1)); else { document.getElementById('screen-main').style.display = 'flex'; }
</script></body></html>